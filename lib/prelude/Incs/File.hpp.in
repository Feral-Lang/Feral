#include "VM/VM.hpp"

namespace fer
{

//////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////// Functions ////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

FERAL_FUNC(fileLines, 0, false,
           "  var.fn() -> Vec<str>\n"
           "Read all lines in the File `var`, and return them as a list separated by newlines.")
{
    FILE *const file = as<VarFile>(args[0])->getFile();
    char *lineptr    = NULL;
    size_t len       = 0;
    ssize_t read     = 0;

    VarVec *res = vm.makeVar<VarVec>(loc, 0, false);
    while((read = getline(&lineptr, &len, file)) != -1) {
        VarStr *s = vm.makeVar<VarStr>(loc, lineptr);
        while(!s->getVal().empty() && (s->getVal().back() == '\n' || s->getVal().back() == '\r')) {
            s->getVal().pop_back();
        }
        res->push(vm, s, true);
        free(lineptr);
        lineptr = NULL;
    }
    if(lineptr) free(lineptr);
    fseek(file, 0, SEEK_SET);
    return res;
}

FERAL_FUNC(fileSeek, 2, false,
           "  var.fn(offset, origin) -> Int\n"
           "Move the position of File `var` from `origin` by `offset` bytes.\n"
           "`origin` can be one of SEEK_SET / SEEK_CURR / SEEK_END.")
{
    EXPECT(VarInt, args[1], "file seek offset");
    EXPECT(VarInt, args[2], "file seek origin");
    FILE *const file = as<VarFile>(args[0])->getFile();
    long offset      = as<VarInt>(args[1])->getVal();
    int origin       = as<VarInt>(args[2])->getVal();
    return vm.makeVar<VarInt>(loc, fseek(file, offset, origin));
}

FERAL_FUNC(fileEachLine, 0, false,
           "  var.fn() -> FileIterator\n"
           "Create and return an iterator from File `var`.\n"
           "This iterator can be used to loop through each line.")
{
    return vm.makeVar<VarFileIterator>(loc, as<VarFile>(args[0]));
}

FERAL_FUNC(fileIteratorNext, 0, false,
           "  var.fn() -> Str | Nil\n"
           "Fetch the next line from the FileIterator `var`.\n"
           "This function is mainly used by for-in loop.")
{
    VarFileIterator *it = as<VarFileIterator>(args[0]);
    VarStr *res         = vm.makeVar<VarStr>(loc, "");
    if(!it->next(res)) {
        vm.decVarRef(res);
        return vm.getNil();
    }
    return res;
}

FERAL_FUNC(fileReadAll, 0, false,
           "  var.fn() -> Str\n"
           "Read all lines in the File `var` and return a string containing them all.")
{
    FILE *const file = as<VarFile>(args[0])->getFile();
    char *lineptr    = NULL;
    size_t len       = 0;
    ssize_t read     = 0;

    VarStr *res = vm.makeVar<VarStr>(loc, "");
    while((read = getline(&lineptr, &len, file)) != -1) {
        String tmp = lineptr;
        res->getVal() += tmp;
        free(lineptr);
        lineptr = NULL;
    }
    if(lineptr) free(lineptr);
    fseek(file, 0, SEEK_SET);
    return res;
}

FERAL_FUNC(fileReadBlocks, 2, false,
           "  var.fn(blockBegin, blockEnd) -> Vec<Str>\n"
           "Retrieve a list of lines between `blockBegin` and `blockEnd` in File `var`.")
{
    EXPECT(VarStr, args[1], "block begin location");
    EXPECT(VarStr, args[2], "block end location");

    FILE *const file  = as<VarFile>(args[0])->getFile();
    const String &beg = as<VarStr>(args[1])->getVal();
    const String &end = as<VarStr>(args[2])->getVal();

    bool insideBlock = false;
    char *lineptr    = NULL;
    size_t len       = 0;
    ssize_t read     = 0;

    StringRef line;
    String blockContent;
    VarVec *res = vm.makeVar<VarVec>(loc, 0, false);
    while((read = getline(&lineptr, &len, file)) != -1) {
        line = lineptr;
    beginFetch:
        if(line.empty()) continue;
        if(!insideBlock) {
            size_t pos = line.find(beg);
            if(pos == String::npos) continue;
            insideBlock = true;
            if(pos + beg.size() > line.size()) continue;
            else line = line.substr(pos + beg.size());
            goto beginFetch;
        }
        size_t pos = line.find(end);
        if(pos == String::npos) {
            blockContent += line;
            continue;
        }
        blockContent += line.substr(0, pos);
        if(pos + end.size() <= line.size()) line = line.substr(pos + end.size());
        else line = "";
        insideBlock = false;
        res->push(vm, vm.makeVar<VarStr>(loc, blockContent), true);
        blockContent.clear();
        goto beginFetch;
    }

    if(lineptr) free(lineptr);
    fseek(file, 0, SEEK_SET);

    // this should actually never occur since blockContent
    // is always pushed back when end point is found
    // if( !blockContent.empty() ) {
    //     res->push(vm.makeVar<VarStr>(loc, blockContent));
    // }
    assert(blockContent.empty());

    return res;
}

} // namespace fer