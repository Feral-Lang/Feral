#include "VM/Interpreter.hpp"

namespace fer
{

FERAL_FUNC(strAdd, 1, false,
           "  var.fn(other) -> Str\n"
           "Concatenates the strings `var` and `other` and returns the result.")
{
    EXPECT(VarStr, args[1], "string addition");
    VarStr *res = vm.makeVar<VarStr>(loc, as<VarStr>(args[0])->getVal());
    res->getVal() += as<VarStr>(args[1])->getVal();
    return res;
}

FERAL_FUNC(strMul, 1, false,
           "  var.fn(other) -> Str\n"
           "Returns a string that is `var`, `other` number of times.")
{
    EXPECT(VarInt, args[1], "string multiplication");
    StringRef lhs = as<VarStr>(args[0])->getVal();
    int64_t rhs   = as<VarInt>(args[1])->getVal();
    VarStr *res   = vm.makeVar<VarStr>(loc, "");
    for(int64_t i = 1; i < rhs; ++i) { res->getVal() += lhs; }
    return res;
}

FERAL_FUNC(strAssnAdd, 1, false,
           "  var.fn(other) -> var\n"
           "Concatenates the string `other` with `var` returns the updated `var`.")
{
    EXPECT_NO_CONST(args[0], "var");
    EXPECT(VarStr, args[1], "string addition-assn");
    if(!args[1]->is<VarStr>()) {
        vm.fail(loc, "expected string argument for addition assignment, found: ",
                vm.getTypeName(args[1]));
        return nullptr;
    }
    VarStr *res = as<VarStr>(args[0]);
    res->getVal() += as<VarStr>(args[1])->getVal();
    return args[0];
}

FERAL_FUNC(strAssnMul, 1, false,
           "  var.fn(other) -> var\n"
           "Updates and returns `var` that is `var`, `other` number of times.")
{
    EXPECT(VarInt, args[1], "string multiplication-assn");
    EXPECT_NO_CONST(args[0], "var");
    String lhs  = as<VarStr>(args[0])->getVal();
    int64_t rhs = as<VarInt>(args[1])->getVal();
    for(int64_t i = 1; i < rhs; ++i) { as<VarStr>(args[0])->getVal() += lhs; }
    return args[0];
}

// logical functions

FERAL_FUNC(strLT, 1, false,
           "  var.fn(other) -> Bool\n"
           "Returns `true` if `var` is less than `other` lexicographically.")
{
    EXPECT(VarStr, args[1], "string less than");
    StringRef lhs = as<VarStr>(args[0])->getVal();
    StringRef rhs = as<VarStr>(args[1])->getVal();
    return lhs < rhs ? vm.getTrue() : vm.getFalse();
}

FERAL_FUNC(strGT, 1, false,
           "  var.fn(other) -> Bool\n"
           "Returns `true` if `var` is greater than `other` lexicographically.")
{
    EXPECT(VarStr, args[1], "string greater than");
    StringRef lhs = as<VarStr>(args[0])->getVal();
    StringRef rhs = as<VarStr>(args[1])->getVal();
    return lhs > rhs ? vm.getTrue() : vm.getFalse();
}

FERAL_FUNC(strLE, 1, false,
           "  var.fn(other) -> Bool\n"
           "Returns `true` if `var` is less than or equal to `other` lexicographically.")
{
    EXPECT(VarStr, args[1], "string less than or equals");
    StringRef lhs = as<VarStr>(args[0])->getVal();
    StringRef rhs = as<VarStr>(args[1])->getVal();
    return lhs <= rhs ? vm.getTrue() : vm.getFalse();
}

FERAL_FUNC(strGE, 1, false,
           "  var.fn(other) -> Bool\n"
           "Returns `true` if `var` is greater than or equal to `other` lexicographically.")
{
    EXPECT(VarStr, args[1], "string greater than or equals");
    StringRef lhs = as<VarStr>(args[0])->getVal();
    StringRef rhs = as<VarStr>(args[1])->getVal();
    return lhs >= rhs ? vm.getTrue() : vm.getFalse();
}

FERAL_FUNC(strEQ, 1, false,
           "  var.fn(other) -> Bool\n"
           "Returns `true` if `var` and `other` represent same strings.")
{
    if(!args[1]->is<VarStr>()) return vm.getFalse();
    StringRef lhs = as<VarStr>(args[0])->getVal();
    StringRef rhs = as<VarStr>(args[1])->getVal();
    return lhs == rhs ? vm.getTrue() : vm.getFalse();
}

FERAL_FUNC(strNE, 1, false,
           "  var.fn(other) -> Bool\n"
           "Returns `true` if `var` and `other` don't represent same strings.")
{
    if(!args[1]->is<VarStr>()) return vm.getTrue();
    StringRef lhs = as<VarStr>(args[0])->getVal();
    StringRef rhs = as<VarStr>(args[1])->getVal();
    return lhs != rhs ? vm.getTrue() : vm.getFalse();
}

FERAL_FUNC(strAt, 1, false,
           "  var.fn(index) -> Str | Nil\n"
           "Returns the character in `var` at the given `index`, or `Nil` if `var` has less "
           "characters than the provided index.")
{
    EXPECT(VarInt, args[1], "index in string");
    StringRef str = as<VarStr>(args[0])->getVal();
    size_t pos    = as<VarInt>(args[1])->getVal();
    if(pos >= str.size()) return vm.getNil();
    return vm.makeVar<VarStr>(loc, str[pos]);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// Utility /////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

static inline void trim(String &s);

size_t sizePow(size_t base, int exp);
size_t strToBin(StringRef str);

FERAL_FUNC(strSize, 0, false,
           "  var.fn() -> Int\n"
           "Returns the number of characters in the string `var`.")
{
    return vm.makeVar<VarInt>(loc, as<VarStr>(args[0])->getVal().size());
}

FERAL_FUNC(strClear, 0, false,
           "  var.fn() -> Nil\n"
           "Clears out the string `var`.")
{
    as<VarStr>(args[0])->getVal().clear();
    return vm.getNil();
}

FERAL_FUNC(strEmpty, 0, false,
           "  var.fn() -> Bool\n"
           "Returns `true` if the string `var` doesn't contain any characters / is empty.")
{
    return as<VarStr>(args[0])->getVal().size() == 0 ? vm.getTrue() : vm.getFalse();
}

FERAL_FUNC(strFront, 0, false,
           "  var.fn() -> Str | Nil\n"
           "Returns the first character in the string `var` or `nil` if `var` is empty.")
{
    const String &str = as<VarStr>(args[0])->getVal();
    return str.size() == 0 ? (Var *)vm.getNil() : (Var *)vm.makeVar<VarStr>(loc, str.front());
}

FERAL_FUNC(strBack, 0, false,
           "  var.fn() -> Str | Nil\n"
           "Returns the last character in the string `var` or `nil` if `var` is empty.")
{
    String &str = as<VarStr>(args[0])->getVal();
    return str.size() == 0 ? (Var *)vm.getNil() : (Var *)vm.makeVar<VarStr>(loc, str.back());
}

FERAL_FUNC(strPush, 1, false,
           "  var.fn(source) -> var\n"
           "Appends the `source` string into `var` and returns the updated `var`.")
{
    EXPECT_NO_CONST(args[0], "var");
    EXPECT(VarStr, args[1], "string push");
    String &src  = as<VarStr>(args[1])->getVal();
    String &dest = as<VarStr>(args[0])->getVal();
    if(src.size() > 0) dest += src;
    return args[0];
}

FERAL_FUNC(strPop, 0, false,
           "  var.fn() -> var\n"
           "Pops the last character from the string `var` if `var` is not empty, and returns the "
           "updated `var`.")
{
    EXPECT_NO_CONST(args[0], "var");
    String &str = as<VarStr>(args[0])->getVal();
    if(str.size() > 0) str.pop_back();
    return args[0];
}

FERAL_FUNC(strIsChAt, 2, false,
           "  var.fn(position, char) -> Bool\n"
           "Returns `true` if `var` contains `char` at index `position`.")
{
    EXPECT(VarInt, args[1], "index in string");
    EXPECT2(VarStr, VarInt, args[2], "comparison character");
    size_t pos   = as<VarInt>(args[1])->getVal();
    String &dest = as<VarStr>(args[0])->getVal();
    if(pos >= dest.size()) return vm.getFalse();
    String chars;
    if(args[2]->is<VarInt>()) {
        chars = as<VarInt>(args[2])->getVal();
    } else if(args[2]->is<VarStr>()) {
        chars = as<VarStr>(args[2])->getVal();
    }
    return chars.find(dest[pos]) == String::npos ? vm.getFalse() : vm.getTrue();
}

FERAL_FUNC(strSetAt, 2, false,
           "  var.fn(position, char) -> var\n"
           "Sets `char` at index `position` in `var` and returns the updated `var`.")
{
    EXPECT_NO_CONST(args[0], "var");
    EXPECT(VarInt, args[1], "index in string");
    EXPECT(VarStr, args[2], "insertion character");
    size_t pos   = as<VarInt>(args[1])->getVal();
    String &dest = as<VarStr>(args[0])->getVal();
    if(pos >= dest.size()) {
        vm.fail(loc, "position ", pos, " is not within string of length: ", dest.size());
        return nullptr;
    }
    String &src = as<VarStr>(args[2])->getVal();
    if(src.size() == 0) return args[0];
    dest[pos] = src[0];
    return args[0];
}

FERAL_FUNC(strInsert, 2, false,
           "  var.fn(position, data) -> Bool\n"
           "Inserts `data` at index `position` in `var` and returns the updated `var`.")
{
    EXPECT_NO_CONST(args[0], "var");
    EXPECT(VarInt, args[1], "index in string");
    EXPECT(VarStr, args[2], "insertion string");
    size_t pos   = as<VarInt>(args[1])->getVal();
    String &dest = as<VarStr>(args[0])->getVal();
    if(pos > dest.size()) {
        vm.fail(loc, "position ", pos, " is greater than string length: ", dest.size());
        return nullptr;
    }
    String &src = as<VarStr>(args[2])->getVal();
    dest.insert(dest.begin() + pos, src.begin(), src.end());
    return args[0];
}

FERAL_FUNC(strErase, 1, false,
           "  var.fn(position) -> var\n"
           "Removes the char at index `position` in `var` and returns the updated `var`.")
{
    EXPECT_NO_CONST(args[0], "var");
    EXPECT(VarInt, args[1], "index in string");
    size_t pos  = as<VarInt>(args[1])->getVal();
    String &str = as<VarStr>(args[0])->getVal();
    if(pos < str.size()) str.erase(str.begin() + pos);
    return args[0];
}

FERAL_FUNC(strFind, 1, false,
           "  var.fn(data) -> Int\n"
           "Returns the position / index of the first occurrence of `data` in `var`. If it's not "
           "found, returns -1.")
{
    EXPECT(VarStr, args[1], "search string");
    String &str  = as<VarStr>(args[0])->getVal();
    String &what = as<VarStr>(args[1])->getVal();
    size_t pos   = str.find(what);
    if(pos == String::npos) { return vm.makeVar<VarInt>(loc, -1); }
    return vm.makeVar<VarInt>(loc, pos);
}

FERAL_FUNC(strRFind, 1, false,
           "  var.fn(data) -> Int\n"
           "Returns the position / index of the last occurrence of `data` in `var`. If it's not "
           "found, returns -1.")
{
    EXPECT(VarStr, args[1], "search string");
    String &str  = as<VarStr>(args[0])->getVal();
    String &what = as<VarStr>(args[1])->getVal();
    size_t pos   = str.rfind(what);
    if(pos == String::npos) { return vm.makeVar<VarInt>(loc, -1); }
    return vm.makeVar<VarInt>(loc, pos);
}

FERAL_FUNC(strSubstrNative, 2, false, "")
{
    EXPECT(VarInt, args[1], "start position");
    EXPECT(VarInt, args[2], "number of characters");
    size_t pos  = as<VarInt>(args[1])->getVal();
    size_t len  = as<VarInt>(args[2])->getVal();
    String &str = as<VarStr>(args[0])->getVal();
    return vm.makeVar<VarStr>(loc, str.substr(pos, len));
}

FERAL_FUNC(strTrim, 0, false,
           "  var.fn() -> var\n"
           "Trims the string `var` - removing any space/tab/newline characters from the beginning "
           "and the end of the string, and returns the updated `var`.")
{
    String &str = as<VarStr>(args[0])->getVal();
    trim(str);
    return args[0];
}

FERAL_FUNC(strLower, 0, false,
           "  var.fn() -> Str\n"
           "Converts all the upper case charcters in the string `var` to lower case and returns "
           "that as a new string.")
{
    String str = as<VarStr>(args[0])->getVal();
    size_t len = str.size();
    for(size_t i = 0; i < len; ++i) {
        str[i] = str[i] >= 'A' && str[i] <= 'Z' ? str[i] | 0x60 : str[i];
    }
    return vm.makeVar<VarStr>(loc, str);
}

FERAL_FUNC(strUpper, 0, false,
           "  var.fn() -> Str\n"
           "Converts all the lower case charcters in the string `var` to upper case and returns "
           "that as a new string.")
{
    String str = as<VarStr>(args[0])->getVal();
    size_t len = str.size();
    for(size_t i = 0; i < len; ++i) {
        str[i] = str[i] >= 'a' && str[i] <= 'z' ? str[i] ^ 0x20 : str[i];
    }
    return vm.makeVar<VarStr>(loc, str);
}

FERAL_FUNC(strSplitNative, 2, false, "")
{
    EXPECT(VarStr, args[1], "delimiter");
    EXPECT(VarInt, args[2], "delimit count");
    StringRef str   = as<VarStr>(args[0])->getVal();
    StringRef delim = as<VarStr>(args[1])->getVal();
    if(delim.size() == 0) {
        vm.fail(loc, "found empty delimiter for string split");
        return nullptr;
    }
    int64_t _maxDelimCount = as<VarInt>(args[2])->getVal();
    uint64_t maxDelimCount = std::numeric_limits<uint64_t>().max();
    if(_maxDelimCount >= 0) maxDelimCount = _maxDelimCount;

    VarVec *res = vm.makeVar<VarVec>(loc, 0, false);
    if(str.empty()) return res;
    VarStr *temp       = vm.makeVar<VarStr>(loc, "");
    int64_t delimCount = 0;
    for(auto c : str) {
        if(delim.find(c) != String::npos && delimCount < maxDelimCount) {
            ++delimCount;
            if(temp->getVal().empty()) continue;
            res->push(temp, true);
            temp = vm.makeVar<VarStr>(loc, "");
            continue;
        }
        temp->getVal() += c;
    }
    if(!temp->getVal().empty()) res->push(temp, true);
    return res;
}

FERAL_FUNC(strStartsWith, 1, false,
           "  var.fn(data) -> Bool\n"
           "Returns `true` if the string `var` starts with `data`.")
{
    EXPECT(VarStr, args[1], "compare string");
    const String &str = as<VarStr>(args[0])->getVal();
    String &with      = as<VarStr>(args[1])->getVal();
    return str.rfind(with, 0) == 0 ? vm.getTrue() : vm.getFalse();
}

FERAL_FUNC(strEndsWith, 1, false,
           "  var.fn(data) -> Bool\n"
           "Returns `true` if the string `var` ends with `data`.")
{
    EXPECT(VarStr, args[1], "compare string");
    const String &str = as<VarStr>(args[0])->getVal();
    String &with      = as<VarStr>(args[1])->getVal();
    size_t pos        = str.rfind(with);
    return vm.makeVar<VarBool>(loc, pos != String::npos && pos + with.size() == str.size());
}

FERAL_FUNC(
    strFormat, 0, true,
    "  var.fn(args...) -> Str\n"
    "Applies `args` as the values in the template string `var` and returns the resulting string.\n"
    "For example:\n"
    "  let result = '1 + 2 = {} and 3 + 4 = {}'.fmt(1 + 2, 3 + 4);\n"
    "Here, `result` will be:\n"
    "  '1 + 2 = 3 and 3 + 4 = 7'")
{
    String str    = as<VarStr>(args[0])->getVal();
    size_t argctr = 1;
    for(size_t i = 0; i < str.size(); ++i) {
        if(str[i] != '{') continue;
        if(i > 0 && str[i - 1] == '\\') {
            str.erase(str.begin() + i - 1);
            --i;
            continue;
        }
        size_t start = i;
        ++i;
        String expr;
        Var *base = nullptr;
        if(i < str.size() && str[i] == '}') {
            base = args[argctr++];
            vm.incVarRef(base);
        } else {
            while(i < str.size() && str[i] != '}') expr += str[i++];
            if(i == str.size()) {
                vm.fail(loc, "failed to find ending brace for eval expr: ", expr);
                return nullptr;
            }
            base = vm.eval(loc, expr, true);
            if(!base) {
                vm.fail(loc, "failed to evaluate expr: ", expr);
                return nullptr;
            }
        }
        Var *v = nullptr;
        Array<Var *, 1> tmp{base};
        if(!vm.callVarAndExpect<VarStr>(loc, "str", v, tmp, {})) {
            vm.decVarRef(base);
            return nullptr;
        }
        String res = as<VarStr>(v)->getVal();
        vm.decVarRef(v);
        vm.decVarRef(base);
        str.erase(start, expr.size() + 2); // +2 for braces
        str.insert(str.begin() + start, res.begin(), res.end());
        i = start + res.size() - 1; // -1 for loop increment (++i)
    }
    return vm.makeVar<VarStr>(loc, std::move(str));
}

FERAL_FUNC(hexStrToBinStr, 0, false,
           "  var.fn() -> Str\n"
           "Converts a hexadecimal string `var` to binary string and returns it.")
{
    static std::unordered_map<char, const char *> hextobin = {
        {'0', "0000"}, {'1', "0001"}, {'2', "0010"}, {'3', "0011"}, {'4', "0100"}, {'5', "0101"},
        {'6', "0110"}, {'7', "0111"}, {'8', "1000"}, {'9', "1001"}, {'a', "1010"}, {'b', "1011"},
        {'c', "1100"}, {'d', "1101"}, {'e', "1110"}, {'f', "1111"},
    };

    const String &str = as<VarStr>(args[0])->getVal();
    String bin;
    for(auto &ch : str) {
        char c = tolower(ch);
        if((c < '0' || c > '9') && (c < 'a' || c > 'f')) {
            vm.fail(loc, "expected hex string, found character: ", c);
            return nullptr;
        }
        bin += hextobin[c];
    }
    while(!bin.empty() && bin.front() == '0') bin.erase(bin.begin());
    return vm.makeVar<VarStr>(loc, bin);
}

FERAL_FUNC(utf8CharFromBinStr, 0, false,
           "  var.fn() -> Str\n"
           "Returns the UTF-8 encoded character as a string from a binary string `var`.")
{
    String str = as<VarStr>(args[0])->getVal();
    if(str.empty()) return vm.makeVar<VarStr>(loc, "");

    // reference: https://en.wikipedia.org/wiki/UTF-8#Encoding
    if(str.size() > 21) {
        vm.fail(loc, "UTF-8 cannot be more than 21 bytes, found bytes: ", str.size());
        return nullptr;
    }

    for(auto &c : str) {
        if(c == '0' || c == '1') continue;
        vm.fail(loc, "expected bin string, found character: ", c);
        return nullptr;
    }

    VarStr *res = vm.makeVar<VarStr>(loc, "");
    String &r   = as<VarStr>(res)->getVal();
    if(str.size() <= 7) {
        while(str.size() < 7) { str.insert(str.begin(), '0'); }
        str.insert(str.begin(), '0');
        r = strToBin(str);
    } else if(str.size() <= 11) {
        while(str.size() < 11) { str.insert(str.begin(), '0'); }
        r = strToBin("110" + str.substr(0, 5));
        r += strToBin("10" + str.substr(5));
    } else if(str.size() <= 16) {
        while(str.size() < 16) { str.insert(str.begin(), '0'); }
        r = strToBin("1110" + str.substr(0, 4));
        r += strToBin("10" + str.substr(4, 6));
        r += strToBin("10" + str.substr(10));
    } else { // str.size() <= 21
        while(str.size() < 21) { str.insert(str.begin(), '0'); }
        r = strToBin("11110" + str.substr(0, 3));
        r += strToBin("10" + str.substr(3, 6));
        r += strToBin("10" + str.substr(9, 6));
        r += strToBin("10" + str.substr(15));
    }

    return res;
}

// character (str[0]) to its ASCII (int)
FERAL_FUNC(byt, 0, false,
           "  var.fn() -> Int\n"
           "Returns the first character (byte) in the string `var` as an integer.")
{
    const String &str = as<VarStr>(args[0])->getVal();
    if(str.empty()) return vm.makeVar<VarInt>(loc, 0);
    return vm.makeVar<VarInt>(loc, (unsigned char)str[0]);
}

// ASCII (int) to character (str)
FERAL_FUNC(chr, 0, false,
           "  var.fn() -> Str\n"
           "Converts the integer `var` (1 byte) into a character and returns it as a string.")
{
    uint8_t byt = (uint8_t)as<VarInt>(args[0])->getVal();
    return vm.makeVar<VarStr>(loc, String(1, byt));
}

FERAL_FUNC(strReplace, 2, false,
           "  var.fn(from, to) -> Str\n"
           "Replaces `from` with `to` in string `var` and returns the resulting string.")
{
    EXPECT(VarStr, args[1], "replace from");
    EXPECT(VarStr, args[2], "replace to");
    StringRef from = as<VarStr>(args[1])->getVal();
    StringRef to   = as<VarStr>(args[2])->getVal();
    String res     = as<VarStr>(args[0])->getVal();
    utils::stringReplace(res, from, to);
    return vm.makeVar<VarStr>(loc, std::move(res));
}

// trim from start (in place)
static inline void ltrim(String &s)
{
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) { return !std::isspace(ch); }));
}

// trim from end (in place)
static inline void rtrim(String &s)
{
    s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch) { return !std::isspace(ch); }).base(),
            s.end());
}

// trim from both ends (in place)
static inline void trim(String &s)
{
    ltrim(s);
    rtrim(s);
}

size_t sizePow(size_t base, int exp)
{
    size_t result = 1;
    while(exp) {
        if(exp % 2) result *= base;
        exp /= 2;
        base *= base;
    }
    return result;
}

size_t strToBin(StringRef str)
{
    size_t exp = sizePow(2, str.size() - 1);
    size_t bin = 0;
    for(auto &c : str) {
        if(c == '1') { bin += exp; }
        exp /= 2;
    }
    return bin;
}

} // namespace fer