#include "VM/VM.hpp"

namespace fer
{

FERAL_FUNC(mapNew, 0, true,
           "  fn(args...) -> Map\n"
           "Creates and returns a new map/dictionary.\n"
           "The args (optional) are key-value pairs to initialize the map with, and hence must be "
           "even in number.\n"
           "Can also accept the following named arguments:\n"
           "  `cap = n` where `n` is the initial capacity of the map\n"
           "  `refs = true` which makes it so that any value inserted in the map is stored as a "
           "reference.")
{
    if((args.size() - 1) % 2 != 0) {
        vm.fail(loc, "argument count must be even to create a map");
        return nullptr;
    }
    Var *orderedv  = assnArgs->getAttr("ordered");
    Var *refsv     = assnArgs->getAttr("refs");
    Var *capv      = assnArgs->getAttr("cap");
    bool ordered   = false;
    size_t resvcap = args.size() - 1;
    bool refs      = false;
    if(orderedv != nullptr) {
        EXPECT(VarBool, orderedv, "'ordered' named argument in map.new()");
        ordered = as<VarBool>(orderedv)->getVal();
    }
    if(refsv != nullptr) {
        EXPECT(VarBool, refsv, "'refs' named argument in map.new()");
        refs = as<VarBool>(refsv)->getVal();
    }
    if(capv != nullptr) {
        EXPECT(VarInt, capv, "'cap' named argument in map.new()");
        resvcap = as<VarInt>(capv)->getVal();
    }
    VarMap *res = vm.makeVar<VarMap>(loc, ordered, refs);
    res->reserve(resvcap);
    for(size_t i = 1; i < args.size(); ++i) {
        Var *v = nullptr;
        Array<Var *, 1> tmp{args[i]};
        if(!vm.callVarAndExpect<VarStr>(loc, "str", v, tmp, {})) return nullptr;
        StringRef key = as<VarStr>(v)->getVal();
        if(refs) {
            res->setAttr(vm, key, args[++i], true);
        } else {
            Var *cp = vm.copyVar(loc, args[++i]);
            if(!cp) {
                vm.decVarRef(v);
                vm.decVarRef(res);
                return nullptr;
            }
            res->setAttr(vm, key, cp, false);
        }
        vm.decVarRef(v);
    }
    return res;
}

FERAL_FUNC(mapCopy, 0, false,
           "  var.fn() -> Map\n"
           "Copies the map data and returns it.")
{
    VarMap *m   = as<VarMap>(args[0]);
    VarMap *res = vm.makeVar<VarMap>(loc, m->isOrdered(), m->isRefMap());
    if(!vm.setVar(res, m)) vm.decVarRef(res);
    return res;
}

FERAL_FUNC(mapSize, 0, false,
           "  var.fn() -> Int\n"
           "Returns the number of elements in the map `var`.")
{
    return vm.makeVar<VarInt>(loc, as<VarMap>(args[0])->getVal().size());
}

FERAL_FUNC(mapIsOrdered, 0, false,
           "  var.fn() -> Bool\n"
           "Returns `true` if the map `var` is ordered.")
{
    return as<VarMap>(args[0])->isOrdered() ? vm.getTrue() : vm.getFalse();
}

FERAL_FUNC(mapIsRef, 0, false,
           "  var.fn() -> Bool\n"
           "Returns `true` if the map `var` stores values as references.")
{
    return as<VarMap>(args[0])->isRefMap() ? vm.getTrue() : vm.getFalse();
}

FERAL_FUNC(mapEmpty, 0, false,
           "  var.fn() -> Bool\n"
           "Returns `true` if the map `var` is empty.")
{
    return as<VarMap>(args[0])->getVal().empty() ? vm.getTrue() : vm.getFalse();
}

FERAL_FUNC(mapInsert, 2, false,
           "  var.fn(key, value) -> var\n"
           "Stores the `value` at `key` in `var` and returns `var`.\n"
           "The key is always converted into a string using its `.str()` method.")
{
    VarMap *map = as<VarMap>(args[0]);
    Var *v      = nullptr;
    Array<Var *, 1> tmp{args[1]};
    if(!vm.callVarAndExpect<VarStr>(loc, "str", v, tmp, {})) return nullptr;
    StringRef key = as<VarStr>(v)->getVal();
    if(map->isRefMap()) {
        map->setAttr(vm, key, args[2], true);
    } else {
        Var *val = vm.copyVar(loc, args[2]);
        if(!val) {
            vm.decVarRef(v);
            return nullptr;
        }
        map->setAttr(vm, key, val, false);
    }
    vm.decVarRef(v);
    return args[0];
}

FERAL_FUNC(
    mapErase, 1, false,
    "  var.fn(key) -> var\n"
    "Deletes the given `key` and its respective value from the map `var`, and returns `var`.")
{
    StringMap<Var *> &map = as<VarMap>(args[0])->getVal();
    Var *v                = nullptr;
    Array<Var *, 1> tmp{args[1]};
    if(!vm.callVarAndExpect<VarStr>(loc, "str", v, tmp, {})) return nullptr;
    auto maploc = map.find(as<VarStr>(v)->getVal());
    if(maploc != map.end()) {
        vm.decVarRef(maploc->second);
        map.erase(maploc);
    }
    vm.decVarRef(v);
    return args[0];
}

FERAL_FUNC(mapClear, 0, false,
           "  var.fn() -> Nil\n"
           "Removes all key-value pairs from the map `var`.")
{
    as<VarMap>(args[0])->clear(vm);
    return vm.getNil();
}

FERAL_FUNC(mapAt, 1, false,
           "  var.fn(key) -> value | Nil\n"
           "Returns the value at `key` or `nil` if the map `var` doesn't contain the `key`.")
{
    VarMap *map = as<VarMap>(args[0]);
    Var *v      = nullptr;
    Array<Var *, 1> tmp{args[1]};
    if(!vm.callVarAndExpect<VarStr>(loc, "str", v, tmp, {})) return nullptr;
    Var *res = map->getAttr(as<VarStr>(v)->getVal());
    vm.decVarRef(v);
    return res ? res : vm.getNil();
}

FERAL_FUNC(mapFind, 1, false,
           "  var.fn(key) -> Bool\n"
           "Returns `true` if the `key` exists in the map `var`.")
{
    VarMap *map = as<VarMap>(args[0]);
    Var *v      = nullptr;
    Array<Var *, 1> tmp{args[1]};
    if(!vm.callVarAndExpect<VarStr>(loc, "str", v, tmp, {})) return nullptr;
    bool res = map->existsAttr(as<VarStr>(v)->getVal());
    vm.decVarRef(v);
    return res ? vm.getTrue() : vm.getFalse();
}

FERAL_FUNC(mapEach, 0, false,
           "  var.fn() -> MapIterator\n"
           "Returns a MapIterator which can be used to iterate through the key-value pairs in the "
           "map `var`.")
{
    return vm.makeVar<VarMapIterator>(loc, as<VarMap>(args[0]));
}

FERAL_FUNC(mapIteratorNext, 0, false,
           "  var.fn() -> key-value-pair | Nil\n"
           "Returns the next pair from the MapIterator `var`, or `nil` if nothing's left.\n"
           "This function is mainly used by for-in loop.")
{
    VarMapIterator *it = as<VarMapIterator>(args[0]);
    Var *res           = nullptr;
    if(!it->next(vm, loc, res)) return vm.getNil();
    res->setLoadAsRef();
    return res;
}

} // namespace fer