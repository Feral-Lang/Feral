Var *mapNew(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	    const StringMap<AssnArgData> &assn_args)
{
	if((args.size() - 1) % 2 != 0) {
		vm.fail(loc, "argument count must be even to create a map");
		return nullptr;
	}
	auto refloc    = assn_args.find("refs");
	auto caploc    = assn_args.find("cap");
	size_t resvcap = args.size() - 1;
	bool refs      = false;
	if(refloc != assn_args.end()) {
		Var *refsv = refloc->second.val;
		if(!refsv->is<VarBool>()) {
			vm.fail(loc,
				"expected 'refs' named argument to be"
				" of type bool for vec.new(), found: ",
				vm.getTypeName(refsv));
			return nullptr;
		}
		refs = as<VarBool>(refsv)->get();
	}
	if(caploc != assn_args.end()) {
		Var *capv = caploc->second.val;
		if(!capv->is<VarBool>()) {
			vm.fail(loc,
				"expected 'cap' named argument to be"
				" of type int for vec.new(), found: ",
				vm.getTypeName(capv));
			return nullptr;
		}
		resvcap = as<VarInt>(capv)->get();
	}
	StringMap<Var *> mapval;
	mapval.reserve(resvcap);
	for(size_t i = 1; i < args.size(); ++i) {
		Var *v = nullptr;
		Array<Var *, 1> tmp{args[i]};
		if(!vm.callVarAndExpect<VarStr>(loc, "str", v, tmp, {})) return nullptr;
		const String &key = as<VarStr>(v)->get();
		auto maploc	  = mapval.find(key);
		if(maploc != mapval.end()) decref(maploc->second);
		if(refs) {
			incref(args[++i]);
			mapval[key] = args[i];
		} else {
			mapval[key] = args[++i]->copy(loc);
		}
		decref(v);
	}
	return vm.makeVar<VarMap>(loc, std::move(mapval), refs);
}

Var *mapSize(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	     const StringMap<AssnArgData> &assn_args)
{
	return vm.makeVar<VarInt>(loc, as<VarMap>(args[0])->get().size());
}

Var *mapIsRef(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	      const StringMap<AssnArgData> &assn_args)
{
	return as<VarMap>(args[0])->isRefMap() ? vm.getTrue() : vm.getFalse();
}

Var *mapEmpty(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	      const StringMap<AssnArgData> &assn_args)
{
	return as<VarMap>(args[0])->get().empty() ? vm.getTrue() : vm.getFalse();
}

Var *mapInsert(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	       const StringMap<AssnArgData> &assn_args)
{
	VarMap *map = as<VarMap>(args[0]);
	Var *v	    = nullptr;
	Array<Var *, 1> tmp{args[1]};
	if(!vm.callVarAndExpect<VarStr>(loc, "str", v, tmp, {})) return nullptr;
	const String &key = as<VarStr>(v)->get();
	if(map->isRefMap()) {
		map->setAttr(key, args[2], true);
	} else {
		map->setAttr(key, args[2]->copy(loc), false);
	}
	return args[0];
}

Var *mapErase(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	      const StringMap<AssnArgData> &assn_args)
{
	StringMap<Var *> &map = as<VarMap>(args[0])->get();
	Var *v		      = nullptr;
	Array<Var *, 1> tmp{args[1]};
	if(!vm.callVarAndExpect<VarStr>(loc, "str", v, tmp, {})) return nullptr;
	auto maploc = map.find(as<VarStr>(v)->get());
	if(maploc != map.end()) {
		decref(maploc->second);
		map.erase(maploc);
	}
	decref(v);
	return args[0];
}

Var *mapAt(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	   const StringMap<AssnArgData> &assn_args)
{
	VarMap *map = as<VarMap>(args[0]);
	Var *v	    = nullptr;
	Array<Var *, 1> tmp{args[1]};
	if(!vm.callVarAndExpect<VarStr>(loc, "str", v, tmp, {})) return nullptr;
	Var *res = map->getAttr(as<VarStr>(v)->get());
	decref(v);
	return res ? res : vm.getNil();
}

Var *mapFind(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	     const StringMap<AssnArgData> &assn_args)
{
	VarMap *map = as<VarMap>(args[0]);
	Var *v	    = nullptr;
	Array<Var *, 1> tmp{args[1]};
	if(!vm.callVarAndExpect<VarStr>(loc, "str", v, tmp, {})) return nullptr;
	bool res = map->existsAttr(as<VarStr>(v)->get());
	decref(v);
	return res ? vm.getTrue() : vm.getFalse();
}

Var *mapEach(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	     const StringMap<AssnArgData> &assn_args)
{
	return vm.makeVar<VarMapIterator>(loc, as<VarMap>(args[0]));
}

Var *mapIteratorNext(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
		     const StringMap<AssnArgData> &assn_args)
{
	VarMapIterator *it = as<VarMapIterator>(args[0]);
	Var *res	   = nullptr;
	if(!it->next(res, vm, loc)) return vm.getNil();
	res->setLoadAsRef();
	return res;
}