#include <cmath> // std::sqrt()

#include "VM/Interpreter.hpp"

namespace fer
{

#define ARITHI_FUNC(fn, oper)                                                                \
    FERAL_FUNC(int##fn, 1, false,                                                            \
               "  var.fn(other) -> Int\n"                                                    \
               "Int operation " STRINGIFY(fn) " between `var` and `other`.")                 \
    {                                                                                        \
        EXPECT2(VarInt, VarFlt, args[1], "int " STRINGIFY(fn));                              \
        if(args[1]->is<VarInt>()) {                                                          \
            return vm.makeVar<VarInt>(                                                       \
                loc, as<VarInt>(args[0])->getVal() oper as<VarInt>(args[1])->getVal());      \
        }                                                                                    \
        return vm.makeVar<VarInt>(                                                           \
            loc, as<VarInt>(args[0])->getVal() oper(int64_t) as<VarFlt>(args[1])->getVal()); \
    }

#define ARITHI_ASSN_FUNC(fn, oper)                                                              \
    FERAL_FUNC(                                                                                 \
        intAssn##fn, 1, false,                                                                  \
        "  var.fn(other) -> var\n"                                                              \
        "Int assignment operation " STRINGIFY(fn) " between `var` and `other`, returns `var`.") \
    {                                                                                           \
        EXPECT2(VarInt, VarFlt, args[1], "int " STRINGIFY(fn) "-assn");                         \
        EXPECT_NO_CONST(args[0], "var");                                                        \
        if(args[1]->is<VarInt>()) {                                                             \
            as<VarInt>(args[0])->setVal(                                                        \
                as<VarInt>(args[0])->getVal() oper as<VarInt>(args[1])->getVal());              \
            return args[0];                                                                     \
        }                                                                                       \
        as<VarInt>(args[0])->setVal(                                                            \
            as<VarInt>(args[0])->getVal() oper(int64_t) as<VarFlt>(args[1])->getVal());         \
        return args[0];                                                                         \
    }

#define LOGICI_FUNC(fn, sym)                                                                    \
    FERAL_FUNC(int##fn, 1, false,                                                               \
               "  var.fn(other) -> Bool\n"                                                      \
               "Int logical operation " STRINGIFY(name) " between `var` and `other`.")          \
    {                                                                                           \
        EXPECT2(VarInt, VarFlt, args[1], "int logical " STRINGIFY(fn));                         \
        if(args[1]->is<VarInt>()) {                                                             \
            return as<VarInt>(args[0])->getVal() sym as<VarInt>(args[1])->getVal()              \
                       ? vm.getTrue()                                                           \
                       : vm.getFalse();                                                         \
        }                                                                                       \
        return as<VarInt>(args[0])->getVal() sym as<VarFlt>(args[1])->getVal() ? vm.getTrue()   \
                                                                               : vm.getFalse(); \
    }

#define BITWISE_FUNC(fn, sym)                                                        \
    FERAL_FUNC(intB##fn, 1, false,                                                   \
               "  var.fn(other) -> Int\n"                                            \
               "Int bitwise operation " STRINGIFY(fn) " between `var` and `other`.") \
    {                                                                                \
        EXPECT(VarInt, args[1], "int bitwise " STRINGIFY(fn));                       \
        return vm.makeVar<VarInt>(                                                   \
            loc, as<VarInt>(args[0])->getVal() sym as<VarInt>(args[1])->getVal());   \
    }

#define BITWISE_ASSN_FUNC(fn, sym)                                            \
    FERAL_FUNC(intAssnB##fn, 1, false,                                        \
               "  var.fn(other) -> var\n"                                     \
               "Int bitwise-assignment operation " STRINGIFY(                 \
                   fn) " between `var` and `other`, returns `var`.")          \
    {                                                                         \
        EXPECT(VarInt, args[1], "int bitwise " STRINGIFY(fn) "-assn");        \
        EXPECT_NO_CONST(args[0], "var");                                      \
        as<VarInt>(args[0])->setVal(                                          \
            as<VarInt>(args[0])->getVal() sym as<VarInt>(args[1])->getVal()); \
        return args[0];                                                       \
    }

ARITHI_FUNC(Add, +)
ARITHI_FUNC(Sub, -)
ARITHI_FUNC(Mul, *)
ARITHI_FUNC(Mod, %)

ARITHI_ASSN_FUNC(Add, +)
ARITHI_ASSN_FUNC(Sub, -)
ARITHI_ASSN_FUNC(Mul, *)
ARITHI_ASSN_FUNC(Mod, %)

LOGICI_FUNC(LT, <)
LOGICI_FUNC(GT, >)
LOGICI_FUNC(LE, <=)
LOGICI_FUNC(GE, >=)

BITWISE_FUNC(And, &)
BITWISE_FUNC(Or, |)
BITWISE_FUNC(XOr, ^)

BITWISE_ASSN_FUNC(And, &)
BITWISE_ASSN_FUNC(Or, |)
BITWISE_ASSN_FUNC(XOr, ^)

FERAL_FUNC(intCopy, 0, false,
           "  var.fn() -> Int\n"
           "Copies the integer data and returns it.")
{
    return vm.makeVar<VarInt>(loc, as<VarInt>(args[0])->getVal());
}

FERAL_FUNC(intEQ, 1, false,
           "  var.fn(other) -> Bool\n"
           "Returns `true` if `var` and `other` are equal.")
{
    if(!args[1]->is<VarInt>()) return vm.getFalse();
    return as<VarInt>(args[0])->getVal() == as<VarInt>(args[1])->getVal() ? vm.getTrue()
                                                                          : vm.getFalse();
}

FERAL_FUNC(intNE, 1, false,
           "  var.fn(other) -> Bool\n"
           "Returns `true` if `var` and `other` are not equal.")
{
    if(!args[1]->is<VarInt>()) return vm.getTrue();
    return as<VarInt>(args[0])->getVal() == as<VarInt>(args[1])->getVal() ? vm.getFalse()
                                                                          : vm.getTrue();
}

FERAL_FUNC(intDiv, 1, false,
           "  var.fn(other) -> Int\n"
           "Divides `var` by `other` and returns the integral value.")
{
    EXPECT2(VarInt, VarFlt, args[1], "int division");
    if(args[1]->is<VarInt>()) {
        // rhs == 0
        if(as<VarInt>(args[1])->getVal() == 0) {
            vm.fail(loc, "division by zero");
            return nullptr;
        }
        return vm.makeVar<VarInt>(loc,
                                  as<VarInt>(args[0])->getVal() / as<VarInt>(args[1])->getVal());
    }
    // rhs == 0
    if(as<VarFlt>(args[1])->getVal() == 0.0) {
        vm.fail(loc, "division by zero");
        return nullptr;
    }
    return vm.makeVar<VarInt>(loc, as<VarInt>(args[0])->getVal() / as<VarInt>(args[1])->getVal());
}

FERAL_FUNC(intAssnDiv, 1, false,
           "  var.fn(other) -> var\n"
           "Divides `var` by `other` and returns the updated `var`.")
{
    EXPECT2(VarInt, VarFlt, args[1], "int division-assn");
    EXPECT_NO_CONST(args[0], "var");
    if(args[1]->is<VarInt>()) {
        // rhs == 0
        if(as<VarInt>(args[1])->getVal() == 0) {
            vm.fail(loc, "division by zero");
            return nullptr;
        }
        as<VarInt>(args[0])->setVal(as<VarInt>(args[0])->getVal() / as<VarInt>(args[1])->getVal());
        return args[0];
    }
    // rhs == 0
    if(as<VarFlt>(args[1])->getVal() == 0.0) {
        vm.fail(loc, "division by zero");
        return nullptr;
    }
    as<VarInt>(args[0])->setVal(as<VarInt>(args[0])->getVal() / as<VarFlt>(args[1])->getVal());
    return args[0];
}

FERAL_FUNC(intBNot, 0, false,
           "  var.fn() -> Int\n"
           "Applies the bitwise not operation on `var` and returns the value.")
{
    return vm.makeVar<VarInt>(loc, ~as<VarInt>(args[0])->getVal());
}

FERAL_FUNC(intAssnBNot, 0, false,
           "  var.fn() -> var\n"
           "Applies the bitwise not operation on `var` and returns the updated `var`.")
{
    as<VarInt>(args[0])->setVal(~as<VarInt>(args[0])->getVal());
    return args[0];
}

FERAL_FUNC(intPopCnt, 0, false,
           "  var.fn() -> Int\n"
           "Returns the number of set (1) bits in `var`.")
{
    return vm.makeVar<VarInt>(loc, std::popcount((uint64_t)as<VarInt>(args[0])->getVal()));
}

FERAL_FUNC(intLShift, 1, false,
           "  var.fn(other) -> Int\n"
           "Left shifts the bits in `var`, `other` times and returns the value.")
{
    EXPECT(VarInt, args[1], "int left-shift");
    return vm.makeVar<VarInt>(loc, as<VarInt>(args[0])->getVal() << as<VarInt>(args[1])->getVal());
}

FERAL_FUNC(intRShift, 1, false,
           "  var.fn(other) -> Int\n"
           "Right shifts the bits in `var`, `other` times and returns the value.")
{
    EXPECT(VarInt, args[1], "int right-shift");
    return vm.makeVar<VarInt>(loc, as<VarInt>(args[0])->getVal() >> as<VarInt>(args[1])->getVal());
}

FERAL_FUNC(intAssnLShift, 1, false,
           "  var.fn(other) -> Int\n"
           "Left shifts the bits in `var`, `other` times and returns the updated `var`.")
{
    EXPECT(VarInt, args[1], "int left-shift-assn");
    EXPECT_NO_CONST(args[0], "var");
    as<VarInt>(args[0])->setVal(as<VarInt>(args[0])->getVal() << as<VarInt>(args[1])->getVal());
    return args[0];
}

FERAL_FUNC(intAssnRShift, 1, false,
           "  var.fn(other) -> Int\n"
           "Right shifts the bits in `var`, `other` times and returns the updated `var`.")
{
    EXPECT(VarInt, args[1], "int right-shift-assn");
    EXPECT_NO_CONST(args[0], "var");
    as<VarInt>(args[0])->setVal(as<VarInt>(args[0])->getVal() >> as<VarInt>(args[1])->getVal());
    return args[0];
}

FERAL_FUNC(intPow, 1, false,
           "  var.fn(exponent) -> Int\n"
           "Returns the value of `var` raised to the power of `exponent`.")
{
    EXPECT(VarInt, args[1], "int power");
    int64_t base = as<VarInt>(args[0])->getVal();
    int64_t exp  = as<VarInt>(args[1])->getVal();
    int64_t res  = 1;
    if(exp < 0) {
        vm.fail(loc, "int power only works with positive exponents, found: ", exp);
        return nullptr;
    }
    while(exp-- > 0) res *= base;
    return vm.makeVar<VarInt>(loc, res);
}

FERAL_FUNC(intSqRoot, 0, false,
           "  var.fn() -> Int\n"
           "Returns the square root of `var`.")
{
    return vm.makeVar<VarInt>(loc, std::sqrt(as<VarInt>(args[0])->getVal()));
}

FERAL_FUNC(intPreInc, 0, false,
           "  var.fn() -> var\n"
           "Increments `var` by 1 and returns `var`.")
{
    as<VarInt>(args[0])->setVal(as<VarInt>(args[0])->getVal() + 1);
    return args[0];
}

FERAL_FUNC(intPostInc, 0, false,
           "  var.fn() -> Int\n"
           "Increments `var` by 1 and returns the previous value.")
{
    VarInt *res = vm.makeVar<VarInt>(loc, as<VarInt>(args[0])->getVal());
    as<VarInt>(args[0])->setVal(as<VarInt>(args[0])->getVal() + 1);
    return res;
}

FERAL_FUNC(intPreDec, 0, false,
           "  var.fn() -> var\n"
           "Decrements `var` by 1 and returns `var`.")
{
    as<VarInt>(args[0])->setVal(as<VarInt>(args[0])->getVal() - 1);
    return args[0];
}

FERAL_FUNC(intPostDec, 0, false,
           "  var.fn() -> Int\n"
           "Decrements `var` by 1 and returns the previous value.")
{
    VarInt *res = vm.makeVar<VarInt>(loc, as<VarInt>(args[0])->getVal());
    as<VarInt>(args[0])->setVal(as<VarInt>(args[0])->getVal() - 1);
    return res;
}

FERAL_FUNC(intUSub, 0, false,
           "  var.fn() -> Int\n"
           "Returns the negative value of `var`.")
{
    return vm.makeVar<VarInt>(loc, -as<VarInt>(args[0])->getVal());
}

FERAL_FUNC(intRange, 1, true,
           "  fn(start, end, step) -> IntIterator\n"
           "Creates an iterator which starts at `start`, ends at `end` (exclusive), and "
           "increments/decrements by `step`.\n"
           "If `end` and `step` are not provided, `start` becomes 0, `end` becomes the provided "
           "`start`, and `step` becomes 1.")
{
    Var *lhsBase  = args[1];
    Var *rhsBase  = args.size() > 2 ? args[2] : nullptr;
    Var *stepBase = args.size() > 3 ? args[3] : nullptr;

    EXPECT(VarInt, lhsBase, "int range start");
    if(rhsBase) { EXPECT(VarInt, rhsBase, "int range end"); }
    if(stepBase) { EXPECT(VarInt, stepBase, "int range step"); }

    int64_t begin, end, step;
    if(args.size() > 2) begin = as<VarInt>(lhsBase)->getVal();
    else begin = 0;
    if(rhsBase) end = as<VarInt>(rhsBase)->getVal();
    else end = as<VarInt>(lhsBase)->getVal();
    if(stepBase) step = as<VarInt>(stepBase)->getVal();
    else step = 1;
    VarIntIterator *res = vm.makeVar<VarIntIterator>(loc, begin, end, step);
    return res;
}

FERAL_FUNC(getIntIteratorNext, 0, false,
           "  var.fn() -> Int\n"
           "Fetch the next int from the IntIterator `var`.\n"
           "This function is mainly used by for-in loop.")
{
    VarIntIterator *it = as<VarIntIterator>(args[0]);
    int64_t _res;
    if(!it->next(_res)) return vm.getNil();
    VarInt *res = vm.makeVar<VarInt>(loc, _res);
    res->setLoadAsRef();
    return res;
}

} // namespace fer