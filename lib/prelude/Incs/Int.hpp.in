#include <cmath> // std::sqrt()

#include "VM/Interpreter.hpp"

namespace fer
{

#define ARITHI_FUNC(fn, oper)                                                                    \
    FERAL_FUNC(int##fn, 1, false,                                                                \
               "  var.fn(other) -> Int\n"                                                        \
               "Int operation " STRINGIFY(fn) " between `var` and `other`.")                     \
    {                                                                                            \
        if(args[1]->is<VarInt>()) {                                                              \
            return vm.makeVar<VarInt>(                                                           \
                loc, as<VarInt>(args[0])->getVal() oper as<VarInt>(args[1])->getVal());          \
        } else if(args[1]->is<VarFlt>()) {                                                       \
            return vm.makeVar<VarInt>(                                                           \
                loc, as<VarInt>(args[0])->getVal() oper(int64_t) as<VarFlt>(args[1])->getVal()); \
        }                                                                                        \
        vm.fail(loc, "expected int or flt argument for int " STRINGIFY(fn) ", found: ",          \
                vm.getTypeName(args[1]));                                                        \
        return nullptr;                                                                          \
    }

#define ARITHI_ASSN_FUNC(fn, oper)                                                              \
    FERAL_FUNC(                                                                                 \
        intAssn##fn, 1, false,                                                                  \
        "  var.fn(other) -> var\n"                                                              \
        "Int assignment operation " STRINGIFY(fn) " between `var` and `other`, returns `var`.") \
    {                                                                                           \
        if(args[1]->is<VarInt>()) {                                                             \
            as<VarInt>(args[0])->setVal(                                                        \
                as<VarInt>(args[0])->getVal() oper as<VarInt>(args[1])->getVal());              \
            return args[0];                                                                     \
        } else if(args[1]->is<VarFlt>()) {                                                      \
            as<VarInt>(args[0])->setVal(                                                        \
                as<VarInt>(args[0])->getVal() oper(int64_t) as<VarFlt>(args[1])->getVal());     \
            return args[0];                                                                     \
        }                                                                                       \
        vm.fail(loc, "expected int or flt argument for int " STRINGIFY(fn) "-assn, found: ",    \
                vm.getTypeName(args[1]));                                                       \
        return nullptr;                                                                         \
    }

#define LOGICI_FUNC(fn, sym)                                                            \
    FERAL_FUNC(int##fn, 1, false,                                                       \
               "  var.fn(other) -> Bool\n"                                              \
               "Int logical operation " STRINGIFY(name) " between `var` and `other`.")  \
    {                                                                                   \
        if(args[1]->is<VarInt>()) {                                                     \
            return as<VarInt>(args[0])->getVal() sym as<VarInt>(args[1])->getVal()      \
                       ? vm.getTrue()                                                   \
                       : vm.getFalse();                                                 \
        }                                                                               \
        if(args[1]->is<VarFlt>()) {                                                     \
            return as<VarInt>(args[0])->getVal() sym as<VarFlt>(args[1])->getVal()      \
                       ? vm.getTrue()                                                   \
                       : vm.getFalse();                                                 \
        }                                                                               \
        vm.fail(loc, "expected int or flt argument for int " STRINGIFY(fn) ", found: ", \
                vm.getTypeName(args[1]));                                               \
        return nullptr;                                                                 \
    }

#define BITWISE_FUNC(fn, sym)                                                            \
    FERAL_FUNC(intB##fn, 1, false,                                                       \
               "  var.fn(other) -> Int\n"                                                \
               "Int bitwise operation " STRINGIFY(fn) " between `var` and `other`.")     \
    {                                                                                    \
        if(args[1]->is<VarInt>()) {                                                      \
            return vm.makeVar<VarInt>(                                                   \
                loc, as<VarInt>(args[0])->getVal() sym as<VarInt>(args[1])->getVal());   \
        }                                                                                \
        vm.fail(loc, "expected int argument for int bitwise " STRINGIFY(fn) ", found: ", \
                vm.getTypeName(args[1]));                                                \
        return nullptr;                                                                  \
    }

#define BITWISE_ASSN_FUNC(fn, sym)                                                \
    FERAL_FUNC(intAssnB##fn, 1, false,                                            \
               "  var.fn(other) -> var\n"                                         \
               "Int bitwise-assignment operation " STRINGIFY(                     \
                   fn) " between `var` and `other`, returns `var`.")              \
    {                                                                             \
        if(args[1]->is<VarInt>()) {                                               \
            as<VarInt>(args[0])->setVal(                                          \
                as<VarInt>(args[0])->getVal() sym as<VarInt>(args[1])->getVal()); \
            return args[0];                                                       \
        }                                                                         \
        vm.fail(loc,                                                              \
                "expected int argument for int "                                  \
                "bitwise " STRINGIFY(fn) "-assn, found: ",                        \
                vm.getTypeName(args[1]));                                         \
        return nullptr;                                                           \
    }

ARITHI_FUNC(Add, +)
ARITHI_FUNC(Sub, -)
ARITHI_FUNC(Mul, *)
ARITHI_FUNC(Mod, %)

ARITHI_ASSN_FUNC(Add, +)
ARITHI_ASSN_FUNC(Sub, -)
ARITHI_ASSN_FUNC(Mul, *)
ARITHI_ASSN_FUNC(Mod, %)

LOGICI_FUNC(LT, <)
LOGICI_FUNC(GT, >)
LOGICI_FUNC(LE, <=)
LOGICI_FUNC(GE, >=)

BITWISE_FUNC(And, &)
BITWISE_FUNC(Or, |)
BITWISE_FUNC(XOr, ^)

BITWISE_ASSN_FUNC(And, &)
BITWISE_ASSN_FUNC(Or, |)
BITWISE_ASSN_FUNC(XOr, ^)

FERAL_FUNC(intEQ, 1, false,
           "  var.fn(other) -> Bool\n"
           "Returns `true` if `var` and `other` are equal.")
{
    if(!args[1]->is<VarInt>()) return vm.getFalse();
    return as<VarInt>(args[0])->getVal() == as<VarInt>(args[1])->getVal() ? vm.getTrue()
                                                                          : vm.getFalse();
}

FERAL_FUNC(intNE, 1, false,
           "  var.fn(other) -> Bool\n"
           "Returns `true` if `var` and `other` are not equal.")
{
    if(!args[1]->is<VarInt>()) return vm.getTrue();
    return as<VarInt>(args[0])->getVal() == as<VarInt>(args[1])->getVal() ? vm.getFalse()
                                                                          : vm.getTrue();
}

FERAL_FUNC(intDiv, 1, false,
           "  var.fn(other) -> Int\n"
           "Divides `var` by `other` and returns the integral value.")
{
    if(args[1]->is<VarInt>()) {
        // rhs == 0
        if(as<VarInt>(args[1])->getVal() == 0) {
            vm.fail(loc, "division by zero");
            return nullptr;
        }
        return vm.makeVar<VarInt>(loc,
                                  as<VarInt>(args[0])->getVal() / as<VarInt>(args[1])->getVal());
    } else if(args[1]->is<VarFlt>()) {
        // rhs == 0
        if(as<VarFlt>(args[1])->getVal() == 0.0) {
            vm.fail(loc, "division by zero");
            return nullptr;
        }
        return vm.makeVar<VarInt>(loc,
                                  as<VarInt>(args[0])->getVal() / as<VarInt>(args[1])->getVal());
    }
    vm.fail(loc, "expected int or flt argument for int Div, found: ", vm.getTypeName(args[1]));
    return nullptr;
}

FERAL_FUNC(intAssnDiv, 1, false,
           "  var.fn(other) -> var\n"
           "Divides `var` by `other` and returns the updated `var`.")
{
    if(args[1]->is<VarInt>()) {
        // rhs == 0
        if(as<VarInt>(args[1])->getVal() == 0) {
            vm.fail(loc, "division by zero");
            return nullptr;
        }
        as<VarInt>(args[0])->setVal(as<VarInt>(args[0])->getVal() / as<VarInt>(args[1])->getVal());
        return args[0];
    } else if(args[1]->is<VarFlt>()) {
        // rhs == 0
        if(as<VarFlt>(args[1])->getVal() == 0.0) {
            vm.fail(loc, "division by zero");
            return nullptr;
        }
        as<VarInt>(args[0])->setVal(as<VarInt>(args[0])->getVal() / as<VarFlt>(args[1])->getVal());
        return args[0];
    }
    vm.fail(loc, "expected int or flt argument for int Div-assn, found: ", vm.getTypeName(args[1]));
    return nullptr;
}

FERAL_FUNC(intBNot, 0, false,
           "  var.fn() -> Int\n"
           "Applies the bitwise not operation on `var` and returns the value.")
{
    return vm.makeVar<VarInt>(loc, ~as<VarInt>(args[0])->getVal());
}

FERAL_FUNC(intAssnBNot, 0, false,
           "  var.fn() -> var\n"
           "Applies the bitwise not operation on `var` and returns the updated `var`.")
{
    as<VarInt>(args[0])->setVal(~as<VarInt>(args[0])->getVal());
    return args[0];
}

FERAL_FUNC(intPopCnt, 0, false,
           "  var.fn() -> Int\n"
           "Returns the number of set (1) bits in `var`.")
{
    return vm.makeVar<VarInt>(loc, std::popcount((uint64_t)as<VarInt>(args[0])->getVal()));
}

FERAL_FUNC(intLShift, 1, false,
           "  var.fn(other) -> Int\n"
           "Left shifts the bits in `var`, `other` times and returns the value.")
{
    if(args[1]->is<VarInt>()) {
        return vm.makeVar<VarInt>(loc, as<VarInt>(args[0])->getVal()
                                           << as<VarInt>(args[1])->getVal());
    }
    vm.fail(loc,
            "expected int argument "
            "for int leftshift, found: ",
            vm.getTypeName(args[1]));
    return nullptr;
}

FERAL_FUNC(intRShift, 1, false,
           "  var.fn(other) -> Int\n"
           "Right shifts the bits in `var`, `other` times and returns the value.")
{
    if(args[1]->is<VarInt>()) {
        return vm.makeVar<VarInt>(loc,
                                  as<VarInt>(args[0])->getVal() >> as<VarInt>(args[1])->getVal());
    }
    vm.fail(loc,
            "expected int argument "
            "for int rightshift, found: ",
            vm.getTypeName(args[1]));
    return nullptr;
}

FERAL_FUNC(intAssnLShift, 1, false,
           "  var.fn(other) -> Int\n"
           "Left shifts the bits in `var`, `other` times and returns the updated `var`.")
{
    if(args[1]->is<VarInt>()) {
        as<VarInt>(args[0])->setVal(as<VarInt>(args[0])->getVal() << as<VarInt>(args[1])->getVal());
        return args[0];
    }
    vm.fail(loc,
            "expected int argument for int leftshift-assign, found: ", vm.getTypeName(args[1]));
    return nullptr;
}

FERAL_FUNC(intAssnRShift, 1, false,
           "  var.fn(other) -> Int\n"
           "Right shifts the bits in `var`, `other` times and returns the updated `var`.")
{
    if(args[1]->is<VarInt>()) {
        as<VarInt>(args[0])->setVal(as<VarInt>(args[0])->getVal() >> as<VarInt>(args[1])->getVal());
        return args[0];
    }
    vm.fail(loc,
            "expected int argument for int rightshift-assign, found: ", vm.getTypeName(args[1]));
    return nullptr;
}

FERAL_FUNC(intPow, 1, false,
           "  var.fn(exponent) -> Int\n"
           "Returns the value of `var` raised to the power of `exponent`.")
{
    if(!args[1]->is<VarInt>()) {
        vm.fail(loc, "expected int argument for int power, found: ", vm.getTypeName(args[1]));
        return nullptr;
    }
    int64_t base = as<VarInt>(args[0])->getVal();
    int64_t exp  = as<VarInt>(args[1])->getVal();
    int64_t res  = 1;
    if(exp < 0) {
        vm.fail(loc, "int power only works with positive exponents, found: ", exp);
        return nullptr;
    }
    while(exp-- > 0) res *= base;
    return vm.makeVar<VarInt>(loc, res);
}

FERAL_FUNC(intSqRoot, 0, false,
           "  var.fn() -> Int\n"
           "Returns the square root of `var`.")
{
    return vm.makeVar<VarInt>(loc, std::sqrt(as<VarInt>(args[0])->getVal()));
}

FERAL_FUNC(intPreInc, 0, false,
           "  var.fn() -> var\n"
           "Increments `var` by 1 and returns `var`.")
{
    as<VarInt>(args[0])->setVal(as<VarInt>(args[0])->getVal() + 1);
    return args[0];
}

FERAL_FUNC(intPostInc, 0, false,
           "  var.fn() -> Int\n"
           "Increments `var` by 1 and returns the previous value.")
{
    VarInt *res = vm.makeVar<VarInt>(loc, as<VarInt>(args[0])->getVal());
    as<VarInt>(args[0])->setVal(as<VarInt>(args[0])->getVal() + 1);
    return res;
}

FERAL_FUNC(intPreDec, 0, false,
           "  var.fn() -> var\n"
           "Decrements `var` by 1 and returns `var`.")
{
    as<VarInt>(args[0])->setVal(as<VarInt>(args[0])->getVal() - 1);
    return args[0];
}

FERAL_FUNC(intPostDec, 0, false,
           "  var.fn() -> Int\n"
           "Decrements `var` by 1 and returns the previous value.")
{
    VarInt *res = vm.makeVar<VarInt>(loc, as<VarInt>(args[0])->getVal());
    as<VarInt>(args[0])->setVal(as<VarInt>(args[0])->getVal() - 1);
    return res;
}

FERAL_FUNC(intUSub, 0, false,
           "  var.fn() -> Int\n"
           "Returns the negative value of `var`.")
{
    return vm.makeVar<VarInt>(loc, -as<VarInt>(args[0])->getVal());
}

FERAL_FUNC(intRange, 1, true,
           "  fn(start, end, step) -> IntIterator\n"
           "Creates an iterator which starts at `start`, ends at `end` (exclusive), and "
           "increments/decrements by `step`.\n"
           "If `end` and `step` are not provided, `start` becomes 0, `end` becomes the provided "
           "`start`, and `step` becomes 1.")
{
    Var *lhsBase  = args[1];
    Var *rhsBase  = args.size() > 2 ? args[2] : nullptr;
    Var *stepBase = args.size() > 3 ? args[3] : nullptr;

    if(!lhsBase->is<VarInt>()) {
        vm.fail(lhsBase->getLoc(),
                "expected argument 1 to be of type int, found: ", vm.getTypeName(lhsBase));
        return nullptr;
    }
    if(rhsBase && !rhsBase->is<VarInt>()) {
        vm.fail(rhsBase->getLoc(),
                "expected argument 2 to be of type int, found: ", vm.getTypeName(rhsBase));
        return nullptr;
    }
    if(stepBase && !stepBase->is<VarInt>()) {
        vm.fail(stepBase->getLoc(),
                "expected argument 3 to be of type int, found: ", vm.getTypeName(stepBase));
        return nullptr;
    }

    int64_t begin, end, step;
    if(args.size() > 2) begin = as<VarInt>(lhsBase)->getVal();
    else begin = 0;
    if(rhsBase) end = as<VarInt>(rhsBase)->getVal();
    else end = as<VarInt>(lhsBase)->getVal();
    if(stepBase) step = as<VarInt>(stepBase)->getVal();
    else step = 1;
    VarIntIterator *res = vm.makeVar<VarIntIterator>(loc, begin, end, step);
    return res;
}

FERAL_FUNC(getIntIteratorNext, 0, false,
           "  var.fn() -> Int\n"
           "Fetch the next int from the IntIterator `var`.\n"
           "This function is mainly used by for-in loop.")
{
    VarIntIterator *it = as<VarIntIterator>(args[0]);
    int64_t _res;
    if(!it->next(_res)) return vm.getNil();
    VarInt *res = vm.makeVar<VarInt>(loc, _res);
    res->setLoadAsRef();
    return res;
}

} // namespace fer