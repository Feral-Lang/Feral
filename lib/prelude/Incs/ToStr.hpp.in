Var *allToStr(VirtualMachine &vm, ModuleLoc loc, Span<Var *> args,
              const StringMap<AssnArgData> &assnArgs)
{
    VarStr *res = vm.makeVar<VarStr>(loc, "");
    res->getVal() += "Type: ";
    res->getVal() += vm.getTypeName(args[0]);
    res->getVal() += " at ";
    char tmp[24];
    sprintf(tmp, "%p", args[0]);
    res->getVal() += tmp;
    return res;
}

Var *bytebufferToStr(VirtualMachine &vm, ModuleLoc loc, Span<Var *> args,
                     const StringMap<AssnArgData> &assnArgs)
{
    VarBytebuffer *self = as<VarBytebuffer>(args[0]);
    if(self->capacity() == 0) return vm.makeVar<VarStr>(loc, "");
    return vm.makeVar<VarStr>(loc, self->getBuf(), self->getLen());
}

Var *nilToStr(VirtualMachine &vm, ModuleLoc loc, Span<Var *> args,
              const StringMap<AssnArgData> &assnArgs)
{
    return vm.makeVar<VarStr>(loc, "(nil)");
}

Var *boolToStr(VirtualMachine &vm, ModuleLoc loc, Span<Var *> args,
               const StringMap<AssnArgData> &assnArgs)
{
    return vm.makeVar<VarStr>(loc, as<VarBool>(args[0])->getVal() ? "true" : "false");
}

Var *typeIDToStr(VirtualMachine &vm, ModuleLoc loc, Span<Var *> args,
                 const StringMap<AssnArgData> &assnArgs)
{
    VarStr *res = vm.makeVar<VarStr>(loc, "typeid<");
    res->getVal() += std::to_string(as<VarTypeID>(args[0])->getVal());
    res->getVal() += ">";
    return res;
}

Var *intToStr(VirtualMachine &vm, ModuleLoc loc, Span<Var *> args,
              const StringMap<AssnArgData> &assnArgs)
{
    return vm.makeVar<VarStr>(loc, std::to_string(as<VarInt>(args[0])->getVal()));
}

Var *fltToStr(VirtualMachine &vm, ModuleLoc loc, Span<Var *> args,
              const StringMap<AssnArgData> &assnArgs)
{
    return vm.makeVar<VarStr>(loc, std::to_string(as<VarFlt>(args[0])->getVal()));
}

Var *strToStr(VirtualMachine &vm, ModuleLoc loc, Span<Var *> args,
              const StringMap<AssnArgData> &assnArgs)
{
    return args[0];
}

Var *failureToStr(VirtualMachine &vm, ModuleLoc loc, Span<Var *> args,
                  const StringMap<AssnArgData> &assnArgs)
{
    return vm.makeVar<VarStr>(loc, as<VarFailure>(args[0])->getMsg());
}

Var *structToStr(VirtualMachine &vm, ModuleLoc loc, Span<Var *> args,
                 const StringMap<AssnArgData> &assnArgs)
{
    VarStruct *st = as<VarStruct>(args[0]);
    VarStr *res   = vm.makeVar<VarStr>(loc, vm.getTypeName(st->getTypeFnID()));
    res->getVal() += "{";
    for(auto &a : st->getAttrs()) {
        Var *v = nullptr;
        Array<Var *, 1> tmp{a.second};
        if(!vm.callVarAndExpect<VarStr>(loc, "str", v, tmp, {})) {
            vm.decVarRef(res);
            return nullptr;
        }
        res->getVal() += a.first;
        res->getVal() += ": ";
        res->getVal() += as<VarStr>(v)->getVal();
        vm.decVarRef(v);
        res->getVal() += ", ";
    }
    if(!st->getAttrs().empty()) {
        res->getVal().pop_back();
        res->getVal().pop_back();
    }
    res->getVal() += "}";
    return res;
}

// TODO: vecToStr() must be done in feral code as Var::toStr() does not exist
// TODO: mapToStr() must be done in feral code as Var::toStr() does not exist