#include "VM/VM.hpp"

namespace fer
{

FERAL_FUNC(vecNew, 0, true,
           "  fn(args...) -> Vec\n"
           "Creates and returns a new vector/list.\n"
           "The args (optional) are elements to initialize the vector with.\n"
           "Can also accept the following named arguments:\n"
           "  `cap = n` where `n` is the initial capacity of the map\n"
           "  `refs = true` which makes it so that any value inserted in the map is stored as a "
           "reference.")
{
    auto refloc    = assnArgs.find("refs");
    auto caploc    = assnArgs.find("cap");
    size_t resvcap = args.size() - 1;
    bool refs      = false;
    if(refloc != assnArgs.end()) {
        Var *refsv = refloc->second.val;
        EXPECT(VarBool, refsv, "'refs' named argument in vec.new()");
        refs = as<VarBool>(refsv)->getVal();
    }
    if(caploc != assnArgs.end()) {
        Var *capv = caploc->second.val;
        EXPECT(VarInt, capv, "'cap' named argument in vec.new()");
        resvcap = as<VarInt>(capv)->getVal();
    }
    VarVec *res = vm.makeVar<VarVec>(loc, resvcap, refs);
    if(refs) {
        for(size_t i = 1; i < args.size(); ++i) { res->push(vm, args[i], true); }
    } else {
        for(size_t i = 1; i < args.size(); ++i) {
            Var *cp = vm.copyVar(loc, args[i]);
            if(!cp) {
                vm.decVarRef(res);
                return nullptr;
            }
            res->push(vm, cp, false);
        }
    }
    return res;
}

FERAL_FUNC(vecCopy, 0, false,
           "  var.fn() -> Vec\n"
           "Copies the vector data and returns it")
{
    VarVec *v   = as<VarVec>(args[0]);
    VarVec *res = vm.makeVar<VarVec>(loc, v->size(), v->isRefVec());
    if(!res->setVal(vm, v->getVal())) vm.decVarRef(res);
    return res;
}

FERAL_FUNC(vecSize, 0, false,
           "  var.fn() -> Int\n"
           "Returns the number of elements in the vector `var`.")
{
    return vm.makeVar<VarInt>(loc, as<VarVec>(args[0])->size());
}

FERAL_FUNC(vecCapacity, 0, false,
           "  var.fn() -> Int\n"
           "Returns the number of elements in the vector `var`.")
{
    return vm.makeVar<VarInt>(loc, as<VarVec>(args[0])->capacity());
}

FERAL_FUNC(vecIsRef, 0, false,
           "  var.fn() -> Bool\n"
           "Returns `true` if the vector `var` stores values as references.")
{
    return as<VarVec>(args[0])->isRefVec() ? vm.getTrue() : vm.getFalse();
}

FERAL_FUNC(vecEmpty, 0, false,
           "  var.fn() -> Bool\n"
           "Returns `true` if the vector `var` is empty.")
{
    return as<VarVec>(args[0])->empty() ? vm.getTrue() : vm.getFalse();
}

FERAL_FUNC(vecFront, 0, false,
           "  var.fn() -> Var\n"
           "Returns the first element in the vector `var`, or `nil` if the vector is empty.")
{
    return as<VarVec>(args[0])->empty() ? vm.getNil() : as<VarVec>(args[0])->front();
}

FERAL_FUNC(vecBack, 0, false,
           "  var.fn() -> Var\n"
           "Returns the last element in the vector `var`, or `nil` if the vector is empty.")
{
    return as<VarVec>(args[0])->empty() ? vm.getNil() : as<VarVec>(args[0])->back();
}

FERAL_FUNC(vecPush, 1, true,
           "  var.fn(args...) -> var\n"
           "Pushes all the given `args` in the vector `var` and returns `var` itself.")
{
    EXPECT_NO_CONST(args[0], "var");
    VarVec *res = as<VarVec>(args[0]);
    for(size_t i = 1; i < args.size(); ++i) {
        if(res->isRefVec()) {
            res->push(vm, args[i], true);
        } else {
            Var *cp = vm.copyVar(loc, args[i]);
            if(!cp) { return nullptr; }
            res->push(vm, cp, false);
        }
    }
    return args[0];
}

FERAL_FUNC(vecPop, 0, false,
           "  var.fn() -> var\n"
           "Pops the last element in the vector `var` and returns `var` itself.")
{
    EXPECT_NO_CONST(args[0], "var");
    VarVec *res = as<VarVec>(args[0]);
    if(res->empty()) {
        vm.fail(loc, "called pop() on an empty vector");
        return nullptr;
    }
    res->pop(vm, true);
    return args[0];
}

FERAL_FUNC(vecClear, 0, false,
           "  var.fn() -> var\n"
           "Removes all elements from the vector `var` and returns `var` itself.")
{
    EXPECT_NO_CONST(args[0], "var");
    VarVec *v = as<VarVec>(args[0]);
    v->clear(vm);
    return args[0];
}

FERAL_FUNC(vecInsert, 2, false,
           "  var.fn(position, item) -> Nil\n"
           "Inserts `item` at the index `position` in the vector `var` and returns `var` itself.")
{
    EXPECT_NO_CONST(args[0], "var");
    EXPECT(VarInt, args[1], "insert position");
    VarVec *res = as<VarVec>(args[0]);
    size_t pos  = as<VarInt>(args[1])->getVal();
    if(pos >= res->size()) {
        vm.fail(loc, "position ", std::to_string(pos), " is not within vector of length ",
                std::to_string(res->size()));
        return nullptr;
    }
    if(res->isRefVec()) {
        res->insert(vm, pos, args[2], true);
    } else {
        Var *cp = vm.copyVar(loc, args[2]);
        if(!cp) { return nullptr; }
        res->insert(vm, pos, cp, false);
    }
    return args[0];
}

FERAL_FUNC(vecSetAt, 2, false,
           "  var.fn(position, item) -> var\n"
           "Sets (replaces) the `item` at the index `position` in the vector `var` and returns "
           "`var` itself.")
{
    EXPECT_NO_CONST(args[0], "var");
    EXPECT(VarInt, args[1], "set position");
    VarVec *res = as<VarVec>(args[0]);
    size_t pos  = as<VarInt>(args[1])->getVal();
    if(pos >= res->size()) {
        vm.fail(loc, "position ", std::to_string(pos), " is not within vector of length ",
                std::to_string(res->size()));
        return nullptr;
    }
    vm.decVarRef(res->at(pos));
    if(res->isRefVec()) {
        res->at(pos) = vm.incVarRef(args[2]);
    } else {
        Var *cp = vm.copyVar(loc, args[2]);
        if(!cp) { return nullptr; }
        res->at(pos) = cp;
    }
    return args[0];
}

FERAL_FUNC(vecErase, 1, false,
           "  var.fn(position) -> var\n"
           "Deletes the item located at index `position` and returns `var` itself.")
{
    EXPECT_NO_CONST(args[0], "var");
    EXPECT(VarInt, args[1], "erase position");
    VarVec *res = as<VarVec>(args[0]);
    size_t pos  = as<VarInt>(args[1])->getVal();
    if(pos >= res->size()) {
        vm.fail(loc, "position ", std::to_string(pos), " is not within vector of length ",
                std::to_string(res->size()));
        return nullptr;
    }
    res->erase(vm, pos, true);
    return args[0];
}

FERAL_FUNC(vecAppendNative, 3, false, "")
{
    EXPECT_NO_CONST(args[0], "var");
    EXPECT(VarVec, args[1], "source");
    EXPECT(VarInt, args[2], "start index");
    EXPECT(VarInt, args[3], "end index");
    VarVec *dest = as<VarVec>(args[0]);
    VarVec *src  = as<VarVec>(args[1]);
    size_t start = as<VarInt>(args[2])->getVal();
    size_t end   = as<VarInt>(args[3])->getVal();
    if(end == -1 || end > src->size()) end = src->size();
    if(dest->isRefVec()) {
        // for the loop, we are not using iterator format because self append will fail in
        // that case
        // ie. v.append(v) will fail if iterator format is used.
        for(size_t i = start; i < end; ++i) { dest->push(vm, src->at(i), true); }
    } else {
        for(size_t i = start; i < end; ++i) {
            Var *cp = vm.copyVar(loc, src->at(i));
            if(!cp) { return nullptr; }
            dest->push(vm, cp, false);
        }
    }
    return dest;
}

FERAL_FUNC(vecSwap, 2, false,
           "  var.fn(positionA, positionB) -> var\n"
           "Swaps the elements at `positionA` and `positionB` in the vector `var` and returns "
           "`var` itself.")
{
    EXPECT_NO_CONST(args[0], "var");
    EXPECT(VarInt, args[1], "index A");
    EXPECT(VarInt, args[2], "index B");
    as<VarVec>(args[0])->swap(as<VarInt>(args[1])->getVal(), as<VarInt>(args[2])->getVal());
    return args[0];
}

FERAL_FUNC(vecReverse, 0, false,
           "  var.fn() -> var\n"
           "Reverses the vector `var` and returns `var` itself.")
{
    EXPECT_NO_CONST(args[0], "var");
    VarVec *res = as<VarVec>(args[0]);
    std::reverse(res->getVal().begin(), res->getVal().end());
    return args[0];
}

FERAL_FUNC(vecAt, 1, false,
           "  var.fn(position) -> value | Nil\n"
           "Returns the value at index `position` in vector `var`, or `nil` if `position` is out "
           "of range in `var`.")
{
    EXPECT(VarInt, args[1], "index");
    VarVec *res = as<VarVec>(args[0]);
    size_t pos  = as<VarInt>(args[1])->getVal();
    if(pos >= res->size()) return vm.getNil();
    return res->at(pos);
}

FERAL_FUNC(vecSubNative, 2, false, "")
{
    EXPECT(VarInt, args[1], "start index");
    EXPECT(VarInt, args[2], "end index");

    VarVec *v  = as<VarVec>(args[0]);
    size_t beg = as<VarInt>(args[1])->getVal();
    size_t end = as<VarInt>(args[2])->getVal();

    if(beg >= v->size() || end > v->size()) return vm.getNil();

    VarVec *res = vm.makeVar<VarVec>(loc, end - beg > 0 ? end - beg : 0, false);
    if(end <= beg) return res;
    for(size_t i = beg; i < end; ++i) {
        Var *cp = vm.copyVar(loc, v->at(i));
        if(!cp) {
            vm.decVarRef(res);
            return nullptr;
        }
        res->push(vm, cp, false);
    }
    return res;
}

FERAL_FUNC(vecSliceNative, 2, false, "")
{
    EXPECT(VarInt, args[1], "start index");
    EXPECT(VarInt, args[2], "end index");

    VarVec *v  = as<VarVec>(args[0]);
    size_t beg = as<VarInt>(args[1])->getVal();
    size_t end = as<VarInt>(args[2])->getVal();

    if(beg >= v->size() || end > v->size()) return vm.getNil();

    VarVec *res = vm.makeVar<VarVec>(loc, end - beg > 0 ? end - beg : 0, true);
    if(end <= beg) return res;
    for(size_t i = beg; i < end; ++i) { res->push(vm, v->at(i), true); }
    return res;
}

FERAL_FUNC(
    vecEach, 0, false,
    "  var.fn() -> VecIterator\n"
    "Returns a VecIterator which can be used to iterate through the elements in the vector `var`.")
{
    return vm.makeVar<VarVecIterator>(loc, as<VarVec>(args[0]));
}

FERAL_FUNC(vecIteratorNext, 0, false,
           "  var.fn() -> Var | Nil\n"
           "Returns the next element from the VecIterator `var`, or `nil` if nothing's left.\n"
           "This function is mainly used by for-in loop.")
{
    VarVecIterator *it = as<VarVecIterator>(args[0]);
    Var *res           = nullptr;
    if(!it->next(res)) return vm.getNil();
    res->setLoadAsRef();
    return res;
}

} // namespace fer