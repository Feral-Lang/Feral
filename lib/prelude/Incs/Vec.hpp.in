#include "VM/Interpreter.hpp"

namespace fer
{

FERAL_FUNC(vecNew, 0, true,
           "  fn(args...) -> Vec\n"
           "Creates and returns a new vector/list.\n"
           "The args (optional) are elements to initialize the vector with.\n"
           "Can also accept the following named arguments:\n"
           "  `cap = n` where `n` is the initial capacity of the map\n"
           "  `refs = true` which makes it so that any value inserted in the map is stored as a "
           "reference.")
{
    auto refloc    = assnArgs.find("refs");
    auto caploc    = assnArgs.find("cap");
    size_t resvcap = args.size() - 1;
    bool refs      = false;
    if(refloc != assnArgs.end()) {
        Var *refsv = refloc->second.val;
        if(!refsv->is<VarBool>()) {
            vm.fail(loc,
                    "expected 'refs' named argument to be"
                    " of type bool for vec.new(), found: ",
                    vm.getTypeName(refsv));
            return nullptr;
        }
        refs = as<VarBool>(refsv)->getVal();
    }
    if(caploc != assnArgs.end()) {
        Var *capv = caploc->second.val;
        if(!capv->is<VarInt>()) {
            vm.fail(loc,
                    "expected 'cap' named argument to be"
                    " of type int for vec.new(), found: ",
                    vm.getTypeName(capv));
            return nullptr;
        }
        resvcap = as<VarInt>(capv)->getVal();
    }
    VarVec *res = vm.makeVar<VarVec>(loc, resvcap, refs);
    if(refs) {
        for(size_t i = 1; i < args.size(); ++i) {
            vm.incVarRef(args[i]);
            res->push(args[i]);
        }
    } else {
        for(size_t i = 1; i < args.size(); ++i) { res->push(vm.copyVar(loc, args[i])); }
    }
    return res;
}

FERAL_FUNC(vecSize, 0, false,
           "  var.fn() -> Int\n"
           "Returns the number of elements in the vector `var`.")
{
    return vm.makeVar<VarInt>(loc, as<VarVec>(args[0])->size());
}

FERAL_FUNC(vecCapacity, 0, false,
           "  var.fn() -> Int\n"
           "Returns the number of elements in the vector `var`.")
{
    return vm.makeVar<VarInt>(loc, as<VarVec>(args[0])->capacity());
}

FERAL_FUNC(vecIsRef, 0, false,
           "  var.fn() -> Bool\n"
           "Returns `true` if the vector `var` stores values as references.")
{
    return as<VarVec>(args[0])->isRefVec() ? vm.getTrue() : vm.getFalse();
}

FERAL_FUNC(vecEmpty, 0, false,
           "  var.fn() -> Bool\n"
           "Returns `true` if the vector `var` is empty.")
{
    return as<VarVec>(args[0])->isEmpty() ? vm.getTrue() : vm.getFalse();
}

FERAL_FUNC(vecFront, 0, false,
           "  var.fn() -> Var\n"
           "Returns the first element in the vector `var`, or `nil` if the vector is empty.")
{
    return as<VarVec>(args[0])->isEmpty() ? vm.getNil() : as<VarVec>(args[0])->front();
}

FERAL_FUNC(vecBack, 0, false,
           "  var.fn() -> Var\n"
           "Returns the last element in the vector `var`, or `nil` if the vector is empty.")
{
    return as<VarVec>(args[0])->isEmpty() ? vm.getNil() : as<VarVec>(args[0])->back();
}

FERAL_FUNC(vecPush, 1, true,
           "  var.fn(args...) -> var\n"
           "Pushes all the given `args` in the vector `var` and returns `var` itself.")
{
    VarVec *res = as<VarVec>(args[0]);
    for(size_t i = 1; i < args.size(); ++i) {
        if(res->isRefVec()) {
            vm.incVarRef(args[i]);
            res->push(args[i]);
        } else {
            res->push(vm.copyVar(loc, args[i]));
        }
    }
    return args[0];
}

FERAL_FUNC(vecPop, 0, false,
           "  var.fn() -> var\n"
           "Pops the last element in the vector `var` and returns `var` itself.")
{
    VarVec *res = as<VarVec>(args[0]);
    if(res->isEmpty()) {
        vm.fail(loc, "called pop() on an empty vector");
        return nullptr;
    }
    vm.decVarRef(res->back());
    res->pop();
    return args[0];
}

FERAL_FUNC(vecClear, 0, false,
           "  var.fn() -> var\n"
           "Removes all elements from the vector `var` and returns `var` itself.")
{
    VarVec *v = as<VarVec>(args[0]);
    for(auto &e : v->getVal()) { vm.decVarRef(e); }
    v->clear();
    return args[0];
}

FERAL_FUNC(vecInsert, 2, false,
           "  var.fn(position, item) -> Nil\n"
           "Inserts `item` at the index `position` in the vector `var` and returns `var` itself.")
{
    if(!args[1]->is<VarInt>()) {
        vm.fail(loc,
                "expected first argument to be of"
                " type integer for vec.insert(), found: ",
                vm.getTypeName(args[1]));
        return nullptr;
    }
    VarVec *res = as<VarVec>(args[0]);
    size_t pos  = as<VarInt>(args[1])->getVal();
    if(pos >= res->size()) {
        vm.fail(loc, "position ", std::to_string(pos), " is not within vector of length ",
                std::to_string(res->size()));
        return nullptr;
    }
    if(res->isRefVec()) {
        vm.incVarRef(args[2]);
        res->insert(res->begin() + pos, args[2]);
    } else {
        res->insert(res->begin() + pos, vm.copyVar(loc, args[2]));
    }
    return args[0];
}

FERAL_FUNC(vecSetAt, 2, false,
           "  var.fn(position, item) -> var\n"
           "Sets (replaces) the `item` at the index `position` in the vector `var` and returns "
           "`var` itself.")
{
    if(!args[1]->is<VarInt>()) {
        vm.fail(loc,
                "expected first argument to be of "
                "type integer for vec.set(), found: ",
                vm.getTypeName(args[1]));
        return nullptr;
    }
    VarVec *res = as<VarVec>(args[0]);
    size_t pos  = as<VarInt>(args[1])->getVal();
    if(pos >= res->size()) {
        vm.fail(loc, "position ", std::to_string(pos), " is not within vector of length ",
                std::to_string(res->size()));
        return nullptr;
    }
    vm.decVarRef(res->at(pos));
    if(res->isRefVec()) {
        vm.incVarRef(args[2]);
        res->at(pos) = args[2];
    } else {
        res->at(pos) = vm.copyVar(loc, args[2]);
    }
    return args[0];
}

FERAL_FUNC(vecErase, 1, false,
           "  var.fn(position) -> var\n"
           "Deletes the item located at index `position` and returns `var` itself.")
{
    if(!args[1]->is<VarInt>()) {
        vm.fail(loc, "expected argument to be of type integer for vec.erase(), found: ",
                vm.getTypeName(args[1]));
        return nullptr;
    }
    VarVec *res = as<VarVec>(args[0]);
    size_t pos  = as<VarInt>(args[1])->getVal();
    if(pos >= res->size()) {
        vm.fail(loc, "position ", std::to_string(pos), " is not within vector of length ",
                std::to_string(res->size()));
        return nullptr;
    }
    vm.decVarRef(res->at(pos));
    res->erase(res->begin() + pos);
    return args[0];
}

FERAL_FUNC(vecAppendNative, 3, false, "")
{
    if(!args[1]->is<VarVec>()) {
        vm.fail(loc, "expected source to be of type vector for vec.append(), found: ",
                vm.getTypeName(args[1]));
        return nullptr;
    }
    if(!args[2]->is<VarInt>()) {
        vm.fail(loc, "expected start index to be of type int for vec.append(), found: ",
                vm.getTypeName(args[2]));
        return nullptr;
    }
    if(!args[3]->is<VarInt>()) {
        vm.fail(loc, "expected end index to be of type int for vec.append(), found: ",
                vm.getTypeName(args[3]));
        return nullptr;
    }
    VarVec *dest = as<VarVec>(args[0]);
    VarVec *src  = as<VarVec>(args[1]);
    size_t start = as<VarInt>(args[2])->getVal();
    size_t end   = as<VarInt>(args[3])->getVal();
    if(end == -1 || end > src->size()) end = src->size();
    if(dest->isRefVec()) {
        // for the loop, we are not using iterator format because self append will fail in
        // that case
        // ie. v.append(v) will fail if iterator format is used.
        for(size_t i = start; i < end; ++i) {
            Var *e = src->at(i);
            vm.incVarRef(e);
            dest->push(e);
        }
    } else {
        for(size_t i = start; i < end; ++i) {
            Var *e = src->at(i);
            dest->push(vm.copyVar(loc, e));
        }
    }
    return dest;
}

FERAL_FUNC(vecSwap, 2, false,
           "  var.fn(positionA, positionB) -> var\n"
           "Swaps the elements at `positionA` and `positionB` in the vector `var` and returns "
           "`var` itself.")
{
    if(!args[1]->is<VarInt>()) {
        vm.fail(loc, "expected index to be of type int for vec.swap(), found: ",
                vm.getTypeName(args[1]));
        return nullptr;
    }
    if(!args[2]->is<VarInt>()) {
        vm.fail(loc, "expected index to be of type int for vec.swap(), found: ",
                vm.getTypeName(args[2]));
        return nullptr;
    }
    as<VarVec>(args[0])->swap(as<VarInt>(args[1])->getVal(), as<VarInt>(args[2])->getVal());
    return args[0];
}

FERAL_FUNC(vecReverse, 0, false,
           "  var.fn() -> var\n"
           "Reverses the vector `var` and returns `var` itself.")
{
    VarVec *res = as<VarVec>(args[0]);
    std::reverse(res->begin(), res->end());
    return args[0];
}

FERAL_FUNC(vecAt, 1, false,
           "  var.fn(position) -> value | Nil\n"
           "Returns the value at index `position` in vector `var`, or `nil` if `position` is out "
           "of range in `var`.")
{
    if(!args[1]->is<VarInt>()) {
        vm.fail(loc, "expected argument to be of type integer for vec.at(), found: ",
                vm.getTypeName(args[1]));
        return nullptr;
    }
    VarVec *res = as<VarVec>(args[0]);
    size_t pos  = as<VarInt>(args[1])->getVal();
    if(pos >= res->size()) return vm.getNil();
    return res->at(pos);
}

FERAL_FUNC(vecSubNative, 2, false, "")
{
    if(!args[1]->is<VarInt>()) {
        vm.fail(loc,
                "expected starting index to be of"
                " type integer for vec.sub(), found: ",
                vm.getTypeName(args[1]));
        return nullptr;
    }
    if(!args[2]->is<VarInt>()) {
        vm.fail(loc,
                "expected ending index to be of"
                " type integer for vec.sub(), found: ",
                vm.getTypeName(args[2]));
        return nullptr;
    }

    VarVec *v  = as<VarVec>(args[0]);
    size_t beg = as<VarInt>(args[1])->getVal();
    size_t end = as<VarInt>(args[2])->getVal();

    if(beg >= v->size()) {
        vm.fail(loc, "starting index is greater than vector size");
        return nullptr;
    }
    if(end > v->size()) {
        vm.fail(loc, "ending index is greater than vector size");
        return nullptr;
    }
    VarVec *res = vm.makeVar<VarVec>(loc, end - beg > 0 ? end - beg : 0, false);
    if(end <= beg) return res;
    for(size_t i = beg; i < end; ++i) { res->push(vm.copyVar(loc, v->at(i))); }
    return res;
}

FERAL_FUNC(vecSliceNative, 2, false, "")
{
    if(!args[1]->is<VarInt>()) {
        vm.fail(loc, "expected starting index to be of type integer for vec.slice(), found: ",
                vm.getTypeName(args[1]));
        return nullptr;
    }
    if(!args[2]->is<VarInt>()) {
        vm.fail(loc, "expected ending index to be of type integer for vec.slice(), found: ",
                vm.getTypeName(args[2]));
        return nullptr;
    }

    VarVec *v  = as<VarVec>(args[0]);
    size_t beg = as<VarInt>(args[1])->getVal();
    size_t end = as<VarInt>(args[2])->getVal();

    if(beg >= v->size()) {
        vm.fail(loc, "starting index is greater than vector size");
        return nullptr;
    }
    if(end > v->size()) {
        vm.fail(loc, "ending index is greater than vector size");
        return nullptr;
    }
    VarVec *res = vm.makeVar<VarVec>(loc, end - beg > 0 ? end - beg : 0, true);
    if(end <= beg) return res;
    for(size_t i = beg; i < end; ++i) {
        Var *e = v->at(i);
        vm.incVarRef(e);
        res->push(e);
    }
    return res;
}

FERAL_FUNC(
    vecEach, 0, false,
    "  var.fn() -> VecIterator\n"
    "Returns a VecIterator which can be used to iterate through the elements in the vector `var`.")
{
    return vm.makeVar<VarVecIterator>(loc, as<VarVec>(args[0]));
}

FERAL_FUNC(vecIteratorNext, 0, false,
           "  var.fn() -> Var | Nil\n"
           "Returns the next element from the VecIterator `var`, or `nil` if nothing's left.\n"
           "This function is mainly used by for-in loop.")
{
    VarVecIterator *it = as<VarVecIterator>(args[0]);
    Var *res           = nullptr;
    if(!it->next(res)) return vm.getNil();
    res->setLoadAsRef();
    return res;
}

} // namespace fer