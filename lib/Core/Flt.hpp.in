#define ARITHF_FUNC(fn, oper)                                                              \
	Var *flt##fn(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,              \
		     const Map<String, AssnArgData> &assn_args)                            \
	{                                                                                  \
		if(args[1]->is<VarInt>()) {                                                \
			return vm.makeVar<VarFlt>(                                         \
			loc, as<VarFlt>(args[0])->get() oper as<VarInt>(args[1])->get());  \
		} else if(args[1]->is<VarFlt>()) {                                         \
			return vm.makeVar<VarFlt>(                                         \
			loc, as<VarFlt>(args[0])->get() oper as<VarFlt>(args[1])->get());  \
		}                                                                          \
		vm.fail(loc, "expected int or flt arg for flt " STRINGIFY(fn) ", found: ", \
			vm.getTypeName(args[1]));                                          \
		return nullptr;                                                            \
	}

#define ARITHF_ASSN_FUNC(fn, oper)                                                              \
	Var *fltAssn##fn(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,               \
			 const Map<String, AssnArgData> &assn_args)                             \
	{                                                                                       \
		if(args[1]->is<VarInt>()) {                                                     \
			as<VarFlt>(args[0])->set(                                               \
			as<VarFlt>(args[0])->get() oper as<VarInt>(args[1])->get());            \
			return args[0];                                                         \
		} else if(args[1]->is<VarFlt>()) {                                              \
			as<VarFlt>(args[0])->set(                                               \
			as<VarFlt>(args[0])->get() oper as<VarFlt>(args[1])->get());            \
			return args[0];                                                         \
		}                                                                               \
		vm.fail(loc, "expected int or flt arg for flt " STRINGIFY(fn) "-assn, found: ", \
			vm.getTypeName(args[1]));                                               \
		return nullptr;                                                                 \
	}

#define LOGICF_FUNC(name, checksym)                                                               \
	Var *flt##name(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,                   \
		       const Map<String, AssnArgData> &assn_args)                                 \
	{                                                                                         \
		if(args[1]->is<VarFlt>()) {                                                       \
			return as<VarFlt>(args[0])->get() checksym as<VarFlt>(args[1])->get()     \
			       ? vm.getTrue()                                                     \
			       : vm.getFalse();                                                   \
		}                                                                                 \
		vm.fail(loc, "expected int or flt arg for flt " STRINGIFY(name) "-assn, found: ", \
			vm.getTypeName(args[1]));                                                 \
		return nullptr;                                                                   \
	}

ARITHF_FUNC(Add, +)
ARITHF_FUNC(Sub, -)
ARITHF_FUNC(Mul, *)
ARITHF_FUNC(Div, /)

ARITHF_ASSN_FUNC(Add, +)
ARITHF_ASSN_FUNC(Sub, -)
ARITHF_ASSN_FUNC(Mul, *)
ARITHF_ASSN_FUNC(Div, /)

LOGICF_FUNC(LT, <)
LOGICF_FUNC(GT, >)
LOGICF_FUNC(LE, <=)
LOGICF_FUNC(GE, >=)

Var *fltEQ(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	   const Map<String, AssnArgData> &assn_args)
{
	if(!args[1]->is<VarFlt>()) return vm.getFalse();
	return std::fabs(as<VarFlt>(args[0])->get() - as<VarFlt>(args[1])->get()) <
	       (long double)0.0001
	       ? vm.getTrue()
	       : vm.getFalse();
}

Var *fltNE(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	   const Map<String, AssnArgData> &assn_args)
{
	if(!args[1]->is<VarFlt>()) return vm.getTrue();
	return std::fabs(as<VarFlt>(args[0])->get() - as<VarFlt>(args[1])->get()) <
	       (long double)0.0001
	       ? vm.getFalse()
	       : vm.getTrue();
}

Var *fltPreInc(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	       const Map<String, AssnArgData> &assn_args)
{
	as<VarFlt>(args[0])->set(as<VarFlt>(args[0])->get() + 1);
	return args[0];
}

Var *fltPostInc(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
		const Map<String, AssnArgData> &assn_args)
{
	VarFlt *res = vm.makeVar<VarFlt>(loc, as<VarFlt>(args[0])->get());
	as<VarFlt>(args[0])->set(as<VarFlt>(args[0])->get() + 1);
	return res;
}

Var *fltPreDec(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	       const Map<String, AssnArgData> &assn_args)
{
	as<VarFlt>(args[0])->set(as<VarFlt>(args[0])->get() - 1);
	return args[0];
}

Var *fltPostDec(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
		const Map<String, AssnArgData> &assn_args)
{
	VarFlt *res = vm.makeVar<VarFlt>(loc, as<VarFlt>(args[0])->get());
	as<VarFlt>(args[0])->set(as<VarFlt>(args[0])->get() - 1);
	return res;
}

Var *fltUSub(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	     const Map<String, AssnArgData> &assn_args)
{
	return vm.makeVar<VarFlt>(loc, -as<VarFlt>(args[0])->get());
}

Var *fltRound(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	      const Map<String, AssnArgData> &assn_args)
{
	return vm.makeVar<VarInt>(loc, std::round(as<VarFlt>(args[0])->get()));
}

Var *fltPow(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	    const Map<String, AssnArgData> &assn_args)
{
	if(!args[1]->is<VarInt>()) {
		vm.fail(loc, "power must be an integer, found: ", vm.getTypeName(args[1]));
		return nullptr;
	}
	return vm.makeVar<VarFlt>(loc,
				  std::pow(as<VarFlt>(args[0])->get(), as<VarInt>(args[1])->get()));
}

Var *fltSqRoot(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	       const Map<String, AssnArgData> &assn_args)
{
	return vm.makeVar<VarFlt>(loc, std::sqrt(as<VarFlt>(args[0])->get()));
}