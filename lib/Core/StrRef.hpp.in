Var *strRefAdd(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	       const Map<StringRef, AssnArgData> &assn_args)
{
	if(!args[1]->is<VarStr>() && !args[1]->is<VarStrRef>() && !args[1]->is<VarChar>()) {
		vm.fail(loc, {"expected string/stringref/char argument"
			      " for stringref addition, found: ",
			      vm.getTypeName(args[1])});
		return nullptr;
	}
	VarStr *res = vm.makeVar<VarStr>(loc, as<VarStrRef>(args[0])->get());
	if(args[1]->is<VarStr>()) res->get() += as<VarStr>(args[1])->get();
	else if(args[1]->is<VarStrRef>()) res->get() += as<VarStrRef>(args[1])->get();
	else if(args[1]->is<VarChar>()) res->get() += as<VarChar>(args[1])->get();
	return res;
}

Var *strRefMul(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	       const Map<StringRef, AssnArgData> &assn_args)
{
	if(!args[1]->is<VarInt>()) {
		vm.fail(loc, {"expected integer argument for stringref multiplication, found: ",
			      vm.getTypeName(args[1])});
		return nullptr;
	}
	StringRef lhs = as<VarStrRef>(args[0])->get();
	mpz_t i;
	mpz_init_set_si(i, 0);
	mpz_srcptr rhs = as<VarInt>(args[1])->getSrc();
	VarStr *res    = vm.makeVar<VarStr>(loc, "");
	for(; mpz_cmp(i, rhs) < 0; mpz_add_ui(i, i, 1)) {
		res->get() += lhs;
	}
	mpz_clear(i);
	return res;
}

// logical functions

Var *strRefLT(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	      const Map<StringRef, AssnArgData> &assn_args)
{
	if(!args[1]->is<VarStr>() && !args[1]->is<VarStrRef>()) {
		vm.fail(loc, {"expected string/stringref argument for '<', found: ",
			      vm.getTypeName(args[1])});
		return nullptr;
	}
	StringRef lhs = as<VarStrRef>(args[0])->get();
	StringRef rhs =
	args[1]->is<VarStr>() ? as<VarStr>(args[1])->get() : as<VarStrRef>(args[1])->get();
	return lhs < rhs ? vm.getTrue() : vm.getFalse();
}

Var *strRefGT(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	      const Map<StringRef, AssnArgData> &assn_args)
{
	if(!args[1]->is<VarStr>() && !args[1]->is<VarStrRef>()) {
		vm.fail(loc, {"expected string/stringref argument for '>', found: ",
			      vm.getTypeName(args[1])});
		return nullptr;
	}
	StringRef lhs = as<VarStrRef>(args[0])->get();
	StringRef rhs =
	args[1]->is<VarStr>() ? as<VarStr>(args[1])->get() : as<VarStrRef>(args[1])->get();
	return lhs > rhs ? vm.getTrue() : vm.getFalse();
}

Var *strRefLE(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	      const Map<StringRef, AssnArgData> &assn_args)
{
	if(!args[1]->is<VarStr>() && !args[1]->is<VarStrRef>()) {
		vm.fail(loc, {"expected string/stringref argument for '<=', found: ",
			      vm.getTypeName(args[1])});
		return nullptr;
	}
	StringRef lhs = as<VarStrRef>(args[0])->get();
	StringRef rhs =
	args[1]->is<VarStr>() ? as<VarStr>(args[1])->get() : as<VarStrRef>(args[1])->get();
	return lhs <= rhs ? vm.getTrue() : vm.getFalse();
}

Var *strRefGE(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	      const Map<StringRef, AssnArgData> &assn_args)
{
	if(!args[1]->is<VarStr>() && !args[1]->is<VarStrRef>()) {
		vm.fail(loc, {"expected string/stringref argument for '>=', found: ",
			      vm.getTypeName(args[1])});
		return nullptr;
	}
	StringRef lhs = as<VarStrRef>(args[0])->get();
	StringRef rhs =
	args[1]->is<VarStr>() ? as<VarStr>(args[1])->get() : as<VarStrRef>(args[1])->get();
	return lhs >= rhs ? vm.getTrue() : vm.getFalse();
}

Var *strRefEq(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	      const Map<StringRef, AssnArgData> &assn_args)
{
	if(!args[1]->is<VarStr>() && !args[1]->is<VarStrRef>()) return vm.getFalse();
	StringRef lhs = as<VarStrRef>(args[0])->get();
	StringRef rhs =
	args[1]->is<VarStr>() ? as<VarStr>(args[1])->get() : as<VarStrRef>(args[1])->get();
	return lhs == rhs ? vm.getTrue() : vm.getFalse();
}

Var *strRefNe(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	      const Map<StringRef, AssnArgData> &assn_args)
{
	if(!args[1]->is<VarStr>() && !args[1]->is<VarStrRef>()) return vm.getTrue();
	StringRef lhs = as<VarStrRef>(args[0])->get();
	StringRef rhs =
	args[1]->is<VarStr>() ? as<VarStr>(args[1])->get() : as<VarStrRef>(args[1])->get();
	return lhs != rhs ? vm.getTrue() : vm.getFalse();
}

Var *strRefAt(Interpreter &vm, const ModuleLoc *loc, Span<Var *> args,
	      const Map<StringRef, AssnArgData> &assn_args)
{
	if(!args[1]->is<VarInt>()) {
		vm.fail(loc, {"expected argument to be of type integer for stringref.at(), found: ",
			      vm.getTypeName(args[1])});
		return nullptr;
	}
	StringRef str = as<VarStrRef>(args[0])->get();
	size_t pos    = mpz_get_ui(as<VarInt>(args[1])->getSrc());
	if(pos >= str.size()) return vm.getNil();
	return vm.makeVar<VarChar>(loc, str[pos]);
}