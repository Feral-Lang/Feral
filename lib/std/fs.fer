loadlib('std/FS');

######################################################################### Path stuff ##########################################################################

"
  fn(parts...) -> Path
Create and return a Path using each of `parts`, separated by platform directory separator, and normalized.
"
let path = fn(pathparts...) {
    let p = ''.path();
    for part in pathparts.each() {
        p /= part;
    }
    return p.normal();
};

###################################################################### FileSystem stuff #######################################################################

"
  fn(path) -> Bool
Returns `true` if `path` exists.
"
let exists = fn(path) {
    return status(path) != TYPE_NOT_FOUND;
};

"
  fn(path, mode = 'r', shouldClose = true) -> File
Opens a file a returns its handle given the `path` and the `mode` string.
If `shouldClose` is `true`, the file won't be closed when the returned variable goes out of scope.
That is useful for handles like `stdout` and `stderr`.
"
let fopen = fn(file, mode = 'r', mustClose = true) {
    return fopenNative(file, mode, mustClose);
};

"
  fn(dirPath, walkMode = WALK_FILES, fileRegex = '(.*)') -> File
Given a directory path `dirPath`, get all files and/or directories with/without going in subdirectories, based on `walkMode`.
`fileRegex` can be used to filter out the results based on some regular expression.
"
let walkDir = fn(dir, mode = WALK_FILES, regex = '(.*)', .kw) {
    let res = walkDirNative(dir, mode, regex);
    let nameOnly = kw['nameOnly'] != nil && kw['nameOnly'];
    if nameOnly {
        for i in res.each() {
                i = i.relativeTo(dir);
        }
    }
    return res;
};

"
  fn(source, destination) -> Nil
Copy the `source` file to `destination`.
Creates parent directories for `desination` as needed.
"
let install = fn(src, dest) {
    let destParent = dest.parent();
    mkdir(destParent);
    copy(src, dest);
};

"
  fn(source, destination) -> Nil
Creates a symbolic link at `destination` from `source`.
"
let mklink = fn(src, dest) {
    if exists(dest) { remove(dest); }
    if exists(src) && isDir(src) {
        mklinkDir(src, dest);
    } else {
        mklinkFile(src, dest);
    }
};

#################################################################### File descriptor stuff ####################################################################

"
  fn(path, flags = fs.O_CREAT) -> Int
Create and return a file descriptor using `path` and `flags`.
"
let fdCreate = fn(name, flags = O_CREAT) {
    return fdCreateNative(name, flags);
};

"
  fn(path, flags = fs.O_RDONLY) -> Int
Open and return a file descriptor using `path` and `flags`.
"
let fdOpen = fn(name, flags = O_RDONLY) {
    return fdOpenNative(name, flags);
};
