let io = import('std/io');
let os = import('std/os');
let vec = import('std/vec');
let mutex = import('std/mutex');
let atomic = import('std/atomic');
let thread = import('std/thread');

let mtx = mutex.new();
let shouldStop = atomic.newBool(false);
let q = vec.new();

let producer = fn() {
    let i = 0;
    while !shouldStop.get() {
        mtx.lock();
        if q.len() > 10 {
            io.println('Skipping production as queue has > 10 items');
        } else {
            q.push(i);
            io.println('Producer (', thread.getCurrentId(), ') generated: ', i++);
        }
        mtx.unlock();
    }
};

let consumer = fn() {
    while !shouldStop.get() {
        mtx.lock();
        if !q.empty() {
            let x = q.front();
            q.erase(0);
            io.println('Consumer (', thread.getCurrentId(), ') consumed: ', x);
        }
        mtx.unlock();
    }
};

let tpool = vec.new(refs = true);
tpool.push(thread.new(name = 'producer-1', producer));
tpool.push(thread.new(name = 'producer-2', producer));
tpool.push(thread.new(name = 'consumer-1', consumer));
tpool.push(thread.new(name = 'consumer-2', consumer));

os.sleep(5);
shouldStop.set(true);

for t in tpool.each() {
    t.join();
}